# pylint: disable=too-many-lines,too-many-statements
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
import json
import sys
from typing import Any, Callable, Dict, IO, List, Literal, Optional, Type, TypeVar, Union, cast, overload

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.rest import AsyncHttpResponse, HttpRequest
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict

from ... import models as _models
from ..._model_base import SdkJSONEncoder, _deserialize
from ...operations._operations import (
    build_asset_operations_statistics_item_asset_statistics_get_request,
    build_assets_operations_for_point_mosaic_searchid_lon_lat_assets_get_request,
    build_assets_operations_for_tile_mosaic_searchid_tile_matrix_set_id_z_x_y_assets_get_request,
    build_assets_operations_for_tile_mosaic_searchid_z_x_y_assets_get_request,
    build_available_operations_assets_item_assets_get_request,
    build_bounds_operations_item_bounds_get_request,
    build_collection_operations_queryables_collections_collection_id_queryables_get_request,
    build_collection_operations_token_token_collection_id_get_request,
    build_conformance_operations_classes_conformance_get_request,
    build_container_operations_token_token_storage_account_container_get_request,
    build_create_operations_collection_collections_post_request,
    build_create_operations_item_collections_collection_id_items_post_request,
    build_delete_operations_collection_collections_collection_id_delete_request,
    build_delete_operations_item_collections_collection_id_items_item_id_delete_request,
    build_geojson_operations_crop_item_crop_format_post_request,
    build_geojson_operations_crop_item_crop_post_request,
    build_geojson_operations_crop_item_crop_width_x_height_format_post_request,
    build_geojson_operations_statistics_item_statistics_post_request,
    build_get_operations_classmap_legend_legend_classmap_classmap_name_get_request,
    build_get_operations_collection_collections_collection_id_get_request,
    build_get_operations_collections_collections_get_request,
    build_get_operations_interval_legend_legend_interval_classmap_name_get_request,
    build_get_operations_item_collection_collections_collection_id_items_get_request,
    build_get_operations_item_collections_collection_id_items_item_id_get_request,
    build_get_operations_legend_legend_colormap_cmap_name_get_request,
    build_get_operations_tile_vector_collections_collection_id_tilesets_tileset_id_tiles_z_x_y_get_request,
    build_get_operations_tilejson_vector_collections_collection_id_tilesets_tileset_id_tilejson_json_get_request,
    build_info_operations_geojson_item_info_geojson_get_request,
    build_info_operations_item_info_get_request,
    build_info_operations_search_mosaic_searchid_info_get_request,
    build_ingestions_create_request,
    build_ingestions_list_request,
    build_ingestions_read_request,
    build_ingestions_runs_create_request,
    build_ingestions_runs_list_request,
    build_ingestions_runs_read_request,
    build_ingestions_runs_retry_request,
    build_items_create_request,
    build_items_delete_request,
    build_items_get_features_request,
    build_items_get_item_request,
    build_items_patch_request,
    build_items_update_request,
    build_landing_operations_page_get_request,
    build_map_operations_item_map_get_request,
    build_mosaic_operations_info_mosaic_info_get_request,
    build_operations_cancel_all_request,
    build_operations_cancel_request,
    build_operations_download_logs_request,
    build_operations_list_request,
    build_operations_read_request,
    build_part_operations_item_crop_minx_miny_maxx_maxy_format_get_request,
    build_part_operations_item_crop_minx_miny_maxx_maxy_width_x_height_format_get_request,
    build_point_operations_item_point_lon_lat_get_request,
    build_preview_operations_item_preview_format_get_request,
    build_preview_operations_item_preview_get_request,
    build_queryables_operations_queryables_get_request,
    build_register_operations_search_mosaic_register_post_request,
    build_search_operations_search_get_request,
    build_search_operations_search_post_request,
    build_signed_operations_href_sign_get_request,
    build_source_data_types_list_request,
    build_statistics_operations_item_statistics_get_request,
    build_tile_operations_item_tiles_tile_matrix_set_id_z_x_y_format_get_request,
    build_tile_operations_item_tiles_tile_matrix_set_id_z_x_y_get_request,
    build_tile_operations_item_tiles_tile_matrix_set_id_z_x_y_scale_x_format_get_request,
    build_tile_operations_item_tiles_tile_matrix_set_id_z_x_y_scale_x_get_request,
    build_tile_operations_item_tiles_z_x_y_format_get_request,
    build_tile_operations_item_tiles_z_x_y_get_request,
    build_tile_operations_item_tiles_z_x_y_scale_x_format_get_request,
    build_tile_operations_item_tiles_z_x_y_scale_x_get_request,
    build_tile_operations_mosaic_tiles_searchid_tile_matrix_set_id_z_x_y_format_get_request,
    build_tile_operations_mosaic_tiles_searchid_tile_matrix_set_id_z_x_y_get_request,
    build_tile_operations_mosaic_tiles_searchid_tile_matrix_set_id_z_x_y_scale_x_format_get_request,
    build_tile_operations_mosaic_tiles_searchid_tile_matrix_set_id_z_x_y_scale_x_get_request,
    build_tile_operations_mosaic_tiles_searchid_z_x_y_format_get_request,
    build_tile_operations_mosaic_tiles_searchid_z_x_y_get_request,
    build_tile_operations_mosaic_tiles_searchid_z_x_y_scale_x_format_get_request,
    build_tile_operations_mosaic_tiles_searchid_z_x_y_scale_x_get_request,
    build_tilejson_operations_item_tile_matrix_set_id_tilejson_json_get_request,
    build_tilejson_operations_item_tilejson_json_get_request,
    build_tilejson_operations_mosaic_searchid_tile_matrix_set_id_tilejson_json_get_request,
    build_tilejson_operations_mosaic_searchid_tilejson_json_get_request,
    build_update_operations_collection_collections_put_request,
    build_update_operations_item_collections_collection_id_items_item_id_put_request,
    build_wmts_operations_item_tile_matrix_set_id_w_m_t_s_capabilities_xml_get_request,
    build_wmts_operations_item_w_m_t_s_capabilities_xml_get_request,
    build_wmts_operations_mosaic_searchid_tile_matrix_set_id_w_m_t_s_capabilities_xml_get_request,
    build_wmts_operations_mosaic_searchid_w_m_t_s_capabilities_xml_get_request,
)

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
_Unset: Any = object()


class SourceDataTypesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~geocatalog.aio.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`source_data_types` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def list(self, **kwargs: Any) -> List[_models.SourceDataType]:
        """Get source data types in system library.

        :return: list of SourceDataType
        :rtype: list[~geocatalog.models.SourceDataType]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "name": "str",
                        "title": "str"
                    }
                ]
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.SourceDataType]] = kwargs.pop("cls", None)

        _request = build_source_data_types_list_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.SourceDataType], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class IngestionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~geocatalog.aio.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`ingestions` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

        self.runs = IngestionsRunsOperations(self._client, self._config, self._serialize, self._deserialize)

    @distributed_trace_async
    async def list(self, collection_id: str, **kwargs: Any) -> List[_models.IngestionDefinition]:
        """Get ingestions of a catalog.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :return: list of IngestionDefinition
        :rtype: list[~geocatalog.models.IngestionDefinition]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "creationTime": "2020-02-20 00:00:00",
                        "id": "str",
                        "importType": "str",
                        "keepOriginalAssets": bool,
                        "skipExistingItems": bool,
                        "sourceCatalogUrl": "str",
                        "sourceDataType": "str"
                    }
                ]
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.IngestionDefinition]] = kwargs.pop("cls", None)

        _request = build_ingestions_list_request(
            collection_id=collection_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.IngestionDefinition], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def read(self, ingestion_id: str, collection_id: str, **kwargs: Any) -> _models.IngestionDefinition:
        """Get the definition of an ingestion.

        :param ingestion_id: Ingestion id. Required.
        :type ingestion_id: str
        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :return: IngestionDefinition. The IngestionDefinition is compatible with MutableMapping
        :rtype: ~geocatalog.models.IngestionDefinition
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 404
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "importType": "str",
                    "keepOriginalAssets": bool,
                    "skipExistingItems": bool,
                    "sourceCatalogUrl": "str",
                    "sourceDataType": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.IngestionDefinition] = kwargs.pop("cls", None)

        _request = build_ingestions_read_request(
            ingestion_id=ingestion_id,
            collection_id=collection_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.IngestionDefinition, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.IngestionDefinition, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create(
        self,
        collection_id: str,
        definition: _models.IngestionDefinitionCreation,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.IngestionDefinition:
        """Create a new ingestion.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param definition: Definition of the ingestion. Required.
        :type definition: ~geocatalog.models.IngestionDefinitionCreation
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IngestionDefinition. The IngestionDefinition is compatible with MutableMapping
        :rtype: ~geocatalog.models.IngestionDefinition
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                definition = {
                    "importType": "str",
                    "keepOriginalAssets": bool,
                    "skipExistingItems": bool,
                    "sourceCatalogUrl": "str",
                    "sourceDataType": "str"
                }

                # response body for status code(s): 201
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "importType": "str",
                    "keepOriginalAssets": bool,
                    "skipExistingItems": bool,
                    "sourceCatalogUrl": "str",
                    "sourceDataType": "str"
                }
        """

    @overload
    async def create(
        self, collection_id: str, definition: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IngestionDefinition:
        """Create a new ingestion.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param definition: Definition of the ingestion. Required.
        :type definition: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IngestionDefinition. The IngestionDefinition is compatible with MutableMapping
        :rtype: ~geocatalog.models.IngestionDefinition
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "importType": "str",
                    "keepOriginalAssets": bool,
                    "skipExistingItems": bool,
                    "sourceCatalogUrl": "str",
                    "sourceDataType": "str"
                }
        """

    @overload
    async def create(
        self, collection_id: str, definition: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IngestionDefinition:
        """Create a new ingestion.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param definition: Definition of the ingestion. Required.
        :type definition: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IngestionDefinition. The IngestionDefinition is compatible with MutableMapping
        :rtype: ~geocatalog.models.IngestionDefinition
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "importType": "str",
                    "keepOriginalAssets": bool,
                    "skipExistingItems": bool,
                    "sourceCatalogUrl": "str",
                    "sourceDataType": "str"
                }
        """

    @distributed_trace_async
    async def create(
        self, collection_id: str, definition: Union[_models.IngestionDefinitionCreation, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.IngestionDefinition:
        """Create a new ingestion.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param definition: Definition of the ingestion. Is one of the following types:
         IngestionDefinitionCreation, JSON, IO[bytes] Required.
        :type definition: ~geocatalog.models.IngestionDefinitionCreation or JSON or IO[bytes]
        :return: IngestionDefinition. The IngestionDefinition is compatible with MutableMapping
        :rtype: ~geocatalog.models.IngestionDefinition
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                definition = {
                    "importType": "str",
                    "keepOriginalAssets": bool,
                    "skipExistingItems": bool,
                    "sourceCatalogUrl": "str",
                    "sourceDataType": "str"
                }

                # response body for status code(s): 201
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "importType": "str",
                    "keepOriginalAssets": bool,
                    "skipExistingItems": bool,
                    "sourceCatalogUrl": "str",
                    "sourceDataType": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: cast(
                Type[HttpResponseError],
                lambda response: HttpResponseError(
                    response=response, model=_deserialize(_models.BadRequest, response.json())
                ),
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.IngestionDefinition] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(definition, (IOBase, bytes)):
            _content = definition
        else:
            _content = json.dumps(definition, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_ingestions_create_request(
            collection_id=collection_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.IngestionDefinition, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class ItemsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~geocatalog.aio.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`items` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_features(
        self,
        collection_id: str,
        *,
        limit: Optional[int] = None,
        bbox: Optional[List[float]] = None,
        datetime: Optional[str] = None,
        **kwargs: Any
    ) -> _models.STACItemCollection:
        """Fetch features of the feature collection with id ``collectionId``.

        Every feature in a dataset belongs to a collection. A dataset may
        consist of multiple feature collections. A feature collection is often a
        collection of features of a similar type, based on a common schema.").

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :keyword limit: The optional limit parameter recommends the number of items that should be
         present in the response document.

         If the limit parameter value is greater than advertised limit maximum, the server must return
         the
         maximum possible number of items, rather than responding with an error.

         Only items are counted that are on the first level of the collection in the response document.
         Nested objects contained within the explicitly requested items must not be counted.

         Minimum = 1. Maximum = 10000. Default = 10. Default value is None.
        :paramtype limit: int
        :keyword bbox: Only features that have a geometry that intersects the bounding box are
         selected.
         The bounding box is provided as four or six numbers, depending on whether the
         coordinate reference system includes a vertical axis (height or depth):


         * Lower left corner, coordinate axis 1
         * Lower left corner, coordinate axis 2
         * Minimum value, coordinate axis 3 (optional)
         * Upper right corner, coordinate axis 1
         * Upper right corner, coordinate axis 2
         * Maximum value, coordinate axis 3 (optional)

         The coordinate reference system of the values is WGS 84 longitude/latitude
         (http://www.opengis.net/def/crs/OGC/1.3/CRS84).

         For WGS 84 longitude/latitude the values are in most cases the sequence of
         minimum longitude, minimum latitude, maximum longitude and maximum latitude.
         However, in cases where the box spans the antimeridian the first value
         (west-most box edge) is larger than the third value (east-most box edge).

         If the vertical axis is included, the third and the sixth number are
         the bottom and the top of the 3-dimensional bounding box.

         If a feature has multiple spatial geometry properties, it is the decision of the
         server whether only a single spatial geometry property is used to determine
         the extent or all relevant geometries. Default value is None.
        :paramtype bbox: list[float]
        :keyword datetime: Either a date-time or an interval, open or closed. Date and time expressions
         adhere to RFC 3339. Open intervals are expressed using double-dots.

         Examples:


         * A date-time: "2018-02-12T23:20:50Z"
         * A closed interval: "2018-02-12T00:00:00Z/2018-03-18T12:31:12Z"
         * Open intervals: "2018-02-12T00:00:00Z/.." or "../2018-03-18T12:31:12Z"

         Only features that have a temporal property that intersects the value of
         ``datetime`` are selected.

         If a feature has multiple temporal properties, it is the decision of the
         server whether only a single temporal property is used to determine
         the extent or all relevant temporal properties. Default value is None.
        :paramtype datetime: str
        :return: STACItemCollection. The STACItemCollection is compatible with MutableMapping
        :rtype: ~geocatalog.models.STACItemCollection
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 404
                response == {
                    "features": [
                        {
                            "assets": {},
                            "bbox": [
                                0
                            ],
                            "collection": "str",
                            "geometry": {},
                            "id": "str",
                            "links": [
                                {
                                    "href": "str",
                                    "rel": "str",
                                    "title": "str",
                                    "type": "str"
                                }
                            ],
                            "properties": {
                                "datetime": "str"
                            },
                            "stac_extensions": [
                                "str"
                            ],
                            "stac_version": "str",
                            "type": "str"
                        }
                    ],
                    "links": [
                        {
                            "href": "str",
                            "rel": "str",
                            "title": "str",
                            "type": "str"
                        }
                    ],
                    "type": "str",
                    "numberMatched": 0,
                    "numberReturned": 0,
                    "stac_version": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: cast(
                Type[HttpResponseError],
                lambda response: HttpResponseError(
                    response=response, model=_deserialize(_models.BadRequest, response.json())
                ),
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.STACItemCollection] = kwargs.pop("cls", None)

        _request = build_items_get_features_request(
            collection_id=collection_id,
            limit=limit,
            bbox=bbox,
            datetime=datetime,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.STACItemCollection, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.STACItemCollection, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_item(self, collection_id: str, item_id: str, **kwargs: Any) -> _models.STACItem:
        """Fetch a single STAC Item.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item_id: STAC Item id. Required.
        :type item_id: str
        :return: STACItem. The STACItem is compatible with MutableMapping
        :rtype: ~geocatalog.models.STACItem
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 404
                response == {
                    "assets": {},
                    "bbox": [
                        0
                    ],
                    "collection": "str",
                    "geometry": {},
                    "id": "str",
                    "links": [
                        {
                            "href": "str",
                            "rel": "str",
                            "title": "str",
                            "type": "str"
                        }
                    ],
                    "properties": {
                        "datetime": "str"
                    },
                    "stac_extensions": [
                        "str"
                    ],
                    "stac_version": "str",
                    "type": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: cast(
                Type[HttpResponseError],
                lambda response: HttpResponseError(
                    response=response, model=_deserialize(_models.BadRequest, response.json())
                ),
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.STACItem] = kwargs.pop("cls", None)

        _request = build_items_get_item_request(
            collection_id=collection_id,
            item_id=item_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.STACItem, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.STACItem, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create(
        self,
        collection_id: str,
        item: _models.STACPostOrPutItem,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Operation:
        """Create a new STAC item or a set of items in a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item: STAC Item or ItemCollection. Required.
        :type item: ~geocatalog.models.STACPostOrPutItem
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Operation. The Operation is compatible with MutableMapping
        :rtype: ~geocatalog.models.Operation
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                item = {
                    "assets": {},
                    "bbox": [
                        0
                    ],
                    "collection": "str",
                    "geometry": {},
                    "id": "str",
                    "links": [
                        {
                            "href": "str",
                            "rel": "str",
                            "title": "str",
                            "type": "str"
                        }
                    ],
                    "properties": {
                        "datetime": "str"
                    },
                    "stac_extensions": [
                        "str"
                    ],
                    "stac_version": "str",
                    "type": "str"
                }

                # response body for status code(s): 202, 404
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "status": "str",
                    "statusHistory": [
                        {
                            "status": "str",
                            "time": "2020-02-20 00:00:00",
                            "errorMessage": "str"
                        }
                    ],
                    "totalFailedItems": 0,
                    "totalItems": 0,
                    "totalPendingItems": 0,
                    "totalSuccessfullItems": 0,
                    "finishTime": "2020-02-20 00:00:00",
                    "startTime": "2020-02-20 00:00:00"
                }
        """

    @overload
    async def create(
        self,
        collection_id: str,
        item: _models.STACPostOrPutItemCollection,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Operation:
        """Create a new STAC item or a set of items in a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item: STAC Item or ItemCollection. Required.
        :type item: ~geocatalog.models.STACPostOrPutItemCollection
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Operation. The Operation is compatible with MutableMapping
        :rtype: ~geocatalog.models.Operation
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                item = {
                    "features": [
                        {
                            "assets": {},
                            "bbox": [
                                0
                            ],
                            "collection": "str",
                            "geometry": {},
                            "id": "str",
                            "links": [
                                {
                                    "href": "str",
                                    "rel": "str",
                                    "title": "str",
                                    "type": "str"
                                }
                            ],
                            "properties": {
                                "datetime": "str"
                            },
                            "stac_extensions": [
                                "str"
                            ],
                            "stac_version": "str",
                            "type": "str"
                        }
                    ],
                    "type": "str",
                    "links": [
                        {
                            "href": "str",
                            "rel": "str",
                            "title": "str",
                            "type": "str"
                        }
                    ],
                    "numberMatched": 0,
                    "numberReturned": 0,
                    "stac_version": "str"
                }

                # response body for status code(s): 202, 404
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "status": "str",
                    "statusHistory": [
                        {
                            "status": "str",
                            "time": "2020-02-20 00:00:00",
                            "errorMessage": "str"
                        }
                    ],
                    "totalFailedItems": 0,
                    "totalItems": 0,
                    "totalPendingItems": 0,
                    "totalSuccessfullItems": 0,
                    "finishTime": "2020-02-20 00:00:00",
                    "startTime": "2020-02-20 00:00:00"
                }
        """

    @distributed_trace_async
    async def create(
        self,
        collection_id: str,
        item: Union[_models.STACPostOrPutItem, _models.STACPostOrPutItemCollection],
        **kwargs: Any
    ) -> _models.Operation:
        """Create a new STAC item or a set of items in a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item: STAC Item or ItemCollection. Is either a STACPostOrPutItem type or a
         STACPostOrPutItemCollection type. Required.
        :type item: ~geocatalog.models.STACPostOrPutItem or
         ~geocatalog.models.STACPostOrPutItemCollection
        :return: Operation. The Operation is compatible with MutableMapping
        :rtype: ~geocatalog.models.Operation
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                item = {
                    "assets": {},
                    "bbox": [
                        0
                    ],
                    "collection": "str",
                    "geometry": {},
                    "id": "str",
                    "links": [
                        {
                            "href": "str",
                            "rel": "str",
                            "title": "str",
                            "type": "str"
                        }
                    ],
                    "properties": {
                        "datetime": "str"
                    },
                    "stac_extensions": [
                        "str"
                    ],
                    "stac_version": "str",
                    "type": "str"
                }

                # response body for status code(s): 202, 404
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "status": "str",
                    "statusHistory": [
                        {
                            "status": "str",
                            "time": "2020-02-20 00:00:00",
                            "errorMessage": "str"
                        }
                    ],
                    "totalFailedItems": 0,
                    "totalItems": 0,
                    "totalPendingItems": 0,
                    "totalSuccessfullItems": 0,
                    "finishTime": "2020-02-20 00:00:00",
                    "startTime": "2020-02-20 00:00:00"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: cast(
                Type[HttpResponseError],
                lambda response: HttpResponseError(
                    response=response, model=_deserialize(_models.BadRequest, response.json())
                ),
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Operation] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(item, _model_base.Model):
            _content = json.dumps(item, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
        elif isinstance(item, _model_base.Model):
            _content = json.dumps(item, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_items_create_request(
            collection_id=collection_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 404]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 202:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.Operation, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.Operation, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update(
        self,
        collection_id: str,
        item_id: str,
        item: _models.STACPostOrPutItem,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Operation:
        """Update a STAC item in a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item_id: Required.
        :type item_id: str
        :param item: STAC Item. Required.
        :type item: ~geocatalog.models.STACPostOrPutItem
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Operation. The Operation is compatible with MutableMapping
        :rtype: ~geocatalog.models.Operation
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                item = {
                    "assets": {},
                    "bbox": [
                        0
                    ],
                    "collection": "str",
                    "geometry": {},
                    "id": "str",
                    "links": [
                        {
                            "href": "str",
                            "rel": "str",
                            "title": "str",
                            "type": "str"
                        }
                    ],
                    "properties": {
                        "datetime": "str"
                    },
                    "stac_extensions": [
                        "str"
                    ],
                    "stac_version": "str",
                    "type": "str"
                }

                # response body for status code(s): 202, 404
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "status": "str",
                    "statusHistory": [
                        {
                            "status": "str",
                            "time": "2020-02-20 00:00:00",
                            "errorMessage": "str"
                        }
                    ],
                    "totalFailedItems": 0,
                    "totalItems": 0,
                    "totalPendingItems": 0,
                    "totalSuccessfullItems": 0,
                    "finishTime": "2020-02-20 00:00:00",
                    "startTime": "2020-02-20 00:00:00"
                }
        """

    @overload
    async def update(
        self, collection_id: str, item_id: str, item: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Operation:
        """Update a STAC item in a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item_id: Required.
        :type item_id: str
        :param item: STAC Item. Required.
        :type item: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Operation. The Operation is compatible with MutableMapping
        :rtype: ~geocatalog.models.Operation
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202, 404
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "status": "str",
                    "statusHistory": [
                        {
                            "status": "str",
                            "time": "2020-02-20 00:00:00",
                            "errorMessage": "str"
                        }
                    ],
                    "totalFailedItems": 0,
                    "totalItems": 0,
                    "totalPendingItems": 0,
                    "totalSuccessfullItems": 0,
                    "finishTime": "2020-02-20 00:00:00",
                    "startTime": "2020-02-20 00:00:00"
                }
        """

    @overload
    async def update(
        self,
        collection_id: str,
        item_id: str,
        item: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Operation:
        """Update a STAC item in a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item_id: Required.
        :type item_id: str
        :param item: STAC Item. Required.
        :type item: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Operation. The Operation is compatible with MutableMapping
        :rtype: ~geocatalog.models.Operation
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202, 404
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "status": "str",
                    "statusHistory": [
                        {
                            "status": "str",
                            "time": "2020-02-20 00:00:00",
                            "errorMessage": "str"
                        }
                    ],
                    "totalFailedItems": 0,
                    "totalItems": 0,
                    "totalPendingItems": 0,
                    "totalSuccessfullItems": 0,
                    "finishTime": "2020-02-20 00:00:00",
                    "startTime": "2020-02-20 00:00:00"
                }
        """

    @distributed_trace_async
    async def update(
        self, collection_id: str, item_id: str, item: Union[_models.STACPostOrPutItem, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.Operation:
        """Update a STAC item in a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item_id: Required.
        :type item_id: str
        :param item: STAC Item. Is one of the following types: STACPostOrPutItem, JSON, IO[bytes]
         Required.
        :type item: ~geocatalog.models.STACPostOrPutItem or JSON or IO[bytes]
        :return: Operation. The Operation is compatible with MutableMapping
        :rtype: ~geocatalog.models.Operation
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                item = {
                    "assets": {},
                    "bbox": [
                        0
                    ],
                    "collection": "str",
                    "geometry": {},
                    "id": "str",
                    "links": [
                        {
                            "href": "str",
                            "rel": "str",
                            "title": "str",
                            "type": "str"
                        }
                    ],
                    "properties": {
                        "datetime": "str"
                    },
                    "stac_extensions": [
                        "str"
                    ],
                    "stac_version": "str",
                    "type": "str"
                }

                # response body for status code(s): 202, 404
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "status": "str",
                    "statusHistory": [
                        {
                            "status": "str",
                            "time": "2020-02-20 00:00:00",
                            "errorMessage": "str"
                        }
                    ],
                    "totalFailedItems": 0,
                    "totalItems": 0,
                    "totalPendingItems": 0,
                    "totalSuccessfullItems": 0,
                    "finishTime": "2020-02-20 00:00:00",
                    "startTime": "2020-02-20 00:00:00"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: cast(
                Type[HttpResponseError],
                lambda response: HttpResponseError(
                    response=response, model=_deserialize(_models.BadRequest, response.json())
                ),
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Operation] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(item, (IOBase, bytes)):
            _content = item
        else:
            _content = json.dumps(item, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_items_update_request(
            collection_id=collection_id,
            item_id=item_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 404]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 202:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.Operation, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.Operation, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def patch(
        self,
        collection_id: str,
        item_id: str,
        item: _models.STACPostOrPutItem,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Operation:
        """Update a STAC item in a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item_id: Required.
        :type item_id: str
        :param item: STAC Item. Required.
        :type item: ~geocatalog.models.STACPostOrPutItem
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Operation. The Operation is compatible with MutableMapping
        :rtype: ~geocatalog.models.Operation
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                item = {
                    "assets": {},
                    "bbox": [
                        0
                    ],
                    "collection": "str",
                    "geometry": {},
                    "id": "str",
                    "links": [
                        {
                            "href": "str",
                            "rel": "str",
                            "title": "str",
                            "type": "str"
                        }
                    ],
                    "properties": {
                        "datetime": "str"
                    },
                    "stac_extensions": [
                        "str"
                    ],
                    "stac_version": "str",
                    "type": "str"
                }

                # response body for status code(s): 202, 404
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "status": "str",
                    "statusHistory": [
                        {
                            "status": "str",
                            "time": "2020-02-20 00:00:00",
                            "errorMessage": "str"
                        }
                    ],
                    "totalFailedItems": 0,
                    "totalItems": 0,
                    "totalPendingItems": 0,
                    "totalSuccessfullItems": 0,
                    "finishTime": "2020-02-20 00:00:00",
                    "startTime": "2020-02-20 00:00:00"
                }
        """

    @overload
    async def patch(
        self, collection_id: str, item_id: str, item: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Operation:
        """Update a STAC item in a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item_id: Required.
        :type item_id: str
        :param item: STAC Item. Required.
        :type item: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Operation. The Operation is compatible with MutableMapping
        :rtype: ~geocatalog.models.Operation
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202, 404
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "status": "str",
                    "statusHistory": [
                        {
                            "status": "str",
                            "time": "2020-02-20 00:00:00",
                            "errorMessage": "str"
                        }
                    ],
                    "totalFailedItems": 0,
                    "totalItems": 0,
                    "totalPendingItems": 0,
                    "totalSuccessfullItems": 0,
                    "finishTime": "2020-02-20 00:00:00",
                    "startTime": "2020-02-20 00:00:00"
                }
        """

    @overload
    async def patch(
        self,
        collection_id: str,
        item_id: str,
        item: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Operation:
        """Update a STAC item in a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item_id: Required.
        :type item_id: str
        :param item: STAC Item. Required.
        :type item: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Operation. The Operation is compatible with MutableMapping
        :rtype: ~geocatalog.models.Operation
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202, 404
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "status": "str",
                    "statusHistory": [
                        {
                            "status": "str",
                            "time": "2020-02-20 00:00:00",
                            "errorMessage": "str"
                        }
                    ],
                    "totalFailedItems": 0,
                    "totalItems": 0,
                    "totalPendingItems": 0,
                    "totalSuccessfullItems": 0,
                    "finishTime": "2020-02-20 00:00:00",
                    "startTime": "2020-02-20 00:00:00"
                }
        """

    @distributed_trace_async
    async def patch(
        self, collection_id: str, item_id: str, item: Union[_models.STACPostOrPutItem, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.Operation:
        """Update a STAC item in a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item_id: Required.
        :type item_id: str
        :param item: STAC Item. Is one of the following types: STACPostOrPutItem, JSON, IO[bytes]
         Required.
        :type item: ~geocatalog.models.STACPostOrPutItem or JSON or IO[bytes]
        :return: Operation. The Operation is compatible with MutableMapping
        :rtype: ~geocatalog.models.Operation
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                item = {
                    "assets": {},
                    "bbox": [
                        0
                    ],
                    "collection": "str",
                    "geometry": {},
                    "id": "str",
                    "links": [
                        {
                            "href": "str",
                            "rel": "str",
                            "title": "str",
                            "type": "str"
                        }
                    ],
                    "properties": {
                        "datetime": "str"
                    },
                    "stac_extensions": [
                        "str"
                    ],
                    "stac_version": "str",
                    "type": "str"
                }

                # response body for status code(s): 202, 404
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "status": "str",
                    "statusHistory": [
                        {
                            "status": "str",
                            "time": "2020-02-20 00:00:00",
                            "errorMessage": "str"
                        }
                    ],
                    "totalFailedItems": 0,
                    "totalItems": 0,
                    "totalPendingItems": 0,
                    "totalSuccessfullItems": 0,
                    "finishTime": "2020-02-20 00:00:00",
                    "startTime": "2020-02-20 00:00:00"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: cast(
                Type[HttpResponseError],
                lambda response: HttpResponseError(
                    response=response, model=_deserialize(_models.BadRequest, response.json())
                ),
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Operation] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(item, (IOBase, bytes)):
            _content = item
        else:
            _content = json.dumps(item, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_items_patch_request(
            collection_id=collection_id,
            item_id=item_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 404]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 202:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.Operation, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.Operation, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete(self, collection_id: str, item_id: str, **kwargs: Any) -> _models.Operation:
        """Delete a STAC item from a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item_id: Required.
        :type item_id: str
        :return: Operation. The Operation is compatible with MutableMapping
        :rtype: ~geocatalog.models.Operation
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202, 404
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "status": "str",
                    "statusHistory": [
                        {
                            "status": "str",
                            "time": "2020-02-20 00:00:00",
                            "errorMessage": "str"
                        }
                    ],
                    "totalFailedItems": 0,
                    "totalItems": 0,
                    "totalPendingItems": 0,
                    "totalSuccessfullItems": 0,
                    "finishTime": "2020-02-20 00:00:00",
                    "startTime": "2020-02-20 00:00:00"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: cast(
                Type[HttpResponseError],
                lambda response: HttpResponseError(
                    response=response, model=_deserialize(_models.BadRequest, response.json())
                ),
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Operation] = kwargs.pop("cls", None)

        _request = build_items_delete_request(
            collection_id=collection_id,
            item_id=item_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 404]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 202:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.Operation, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.Operation, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class Operations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~geocatalog.aio.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def list(
        self, collection_id: str, *, _top: int, _skip: Optional[int] = None, **kwargs: Any
    ) -> List[_models.OperationSummary]:
        """Get operations of a geo-catalog collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :keyword _top: Number of items to return. Required.
        :paramtype _top: int
        :keyword _skip: Number of items to skip. Default value is None.
        :paramtype _skip: int
        :return: list of OperationSummary
        :rtype: list[~geocatalog.models.OperationSummary]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "id": "str",
                        "status": "str"
                    }
                ]
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.OperationSummary]] = kwargs.pop("cls", None)

        _request = build_operations_list_request(
            collection_id=collection_id,
            _top=_top,
            _skip=_skip,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.OperationSummary], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def read(self, collection_id: str, operation_id: str, **kwargs: Any) -> _models.Operation:
        """Get an operation of a geo-catalog collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param operation_id: Operation id. Required.
        :type operation_id: str
        :return: Operation. The Operation is compatible with MutableMapping
        :rtype: ~geocatalog.models.Operation
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 404
                response == {
                    "creationTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "status": "str",
                    "statusHistory": [
                        {
                            "status": "str",
                            "time": "2020-02-20 00:00:00",
                            "errorMessage": "str"
                        }
                    ],
                    "totalFailedItems": 0,
                    "totalItems": 0,
                    "totalPendingItems": 0,
                    "totalSuccessfullItems": 0,
                    "finishTime": "2020-02-20 00:00:00",
                    "startTime": "2020-02-20 00:00:00"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Operation] = kwargs.pop("cls", None)

        _request = build_operations_read_request(
            collection_id=collection_id,
            operation_id=operation_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.Operation, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.Operation, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def cancel(  # pylint: disable=inconsistent-return-statements
        self, collection_id: str, operation_id: str, **kwargs: Any
    ) -> None:
        """Cancel a running operation of a geo-catalog collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param operation_id: Operation id. Required.
        :type operation_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: cast(
                Type[HttpResponseError],
                lambda response: HttpResponseError(
                    response=response, model=_deserialize(_models.BadRequest, response.json())
                ),
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_operations_cancel_request(
            collection_id=collection_id,
            operation_id=operation_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def cancel_all(  # pylint: disable=inconsistent-return-statements
        self, collection_id: str, **kwargs: Any
    ) -> None:
        """Cancel all running operations of a geo-catalog collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_operations_cancel_all_request(
            collection_id=collection_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def download_logs(self, collection_id: str, operation_id: str, **kwargs: Any) -> bytes:
        """Get operation logs.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param operation_id: Operation id. Required.
        :type operation_id: str
        :return: bytes
        :rtype: bytes
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[bytes] = kwargs.pop("cls", None)

        _request = build_operations_download_logs_request(
            collection_id=collection_id,
            operation_id=operation_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(bytes, response.json(), format="base64")

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(bytes, response.json(), format="base64")

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class collectionOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~geocatalog.aio.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`collection_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def token_token_collection_id_get(
        self, collection_id: str, *, duration: Optional[int] = None, _id: Optional[str] = None, **kwargs: Any
    ) -> _models.SASToken:
        """generate a SAS token for Assets that belong to the given STAC Collection.

        Generate a `SAS
        Token
        <https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview#how-a-shared-access-signature-works>`_
        for the given Collection (e.g. landsat-8-c2-l2).

        :param collection_id: The Collection ID to generate a SAS Token for. Required.
        :type collection_id: str
        :keyword duration: The duration, in minutes, that the SAS token will be valid. Only valid for
         approved users. Default value is None.
        :paramtype duration: int
        :keyword _id: Third party user identifier for metrics tracking. Default value is None.
        :paramtype _id: str
        :return: SASToken. The SASToken is compatible with MutableMapping
        :rtype: ~geocatalog.models.SASToken
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "msft:expiry": "2020-02-20 00:00:00",
                    "token": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SASToken] = kwargs.pop("cls", None)

        _request = build_collection_operations_token_token_collection_id_get_request(
            collection_id=collection_id,
            duration=duration,
            _id=_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SASToken, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class containerOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~geocatalog.aio.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`container_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def token_token_storage_account_container_get(  # pylint: disable=name-too-long
        self,
        storage_account: str,
        container: str,
        *,
        duration: Optional[int] = None,
        _id: Optional[str] = None,
        **kwargs: Any
    ) -> _models.SASToken:
        """generate a SAS Token for the given Azure Blob storage account and container.

        Generate a `SAS
        Token
        <https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview#how-a-shared-access-signature-works>`_
        for the given storage account and container. The storage account and container
        must be associated with a Planetary Computer dataset indexed by the STAC API.

        :param storage_account: The name of the storage account in which the container resides.
         Required.
        :type storage_account: str
        :param container: The name of the container that holds data that will be readable with the
         given
         SAS token. Required.
        :type container: str
        :keyword duration: The duration, in minutes, that the SAS token will be valid. Only valid for
         approved users. Default value is None.
        :paramtype duration: int
        :keyword _id: Third party user identifier for metrics tracking. Default value is None.
        :paramtype _id: str
        :return: SASToken. The SASToken is compatible with MutableMapping
        :rtype: ~geocatalog.models.SASToken
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "msft:expiry": "2020-02-20 00:00:00",
                    "token": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SASToken] = kwargs.pop("cls", None)

        _request = build_container_operations_token_token_storage_account_container_get_request(
            storage_account=storage_account,
            container=container,
            duration=duration,
            _id=_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SASToken, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class signedOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~geocatalog.aio.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`signed_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def href_sign_get(  # pylint: disable=inconsistent-return-statements
        self, *, href: str, duration: Optional[int] = None, _id: Optional[str] = None, **kwargs: Any
    ) -> None:
        """sign an HREF in the format of a URL and returns a SingedLink.

        Signs a HREF (a link URL) by appending a `SAS
        Token
        <https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview#how-a-shared-access-signature-works>`_.
        If the HREF is not a Azure Blob Storage HREF, then pass back the HREF unsigned.

        :keyword href: HREF (URL) to sign. Required.
        :paramtype href: str
        :keyword duration: The duration, in minutes, that the SAS token will be valid. Only valid for
         approved users. Default value is None.
        :paramtype duration: int
        :keyword _id: Third party user identifier for metrics tracking. Default value is None.
        :paramtype _id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_signed_operations_href_sign_get_request(
            href=href,
            duration=duration,
            _id=_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class LandingOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~geocatalog.aio.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`landing_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def page_get(self, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Landing Page.

        Endpoint.

        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_landing_operations_page_get_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class ConformanceOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~geocatalog.aio.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`conformance_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def classes_conformance_get(self, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Conformance Classes.

        Endpoint.

        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_conformance_operations_classes_conformance_get_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class GetOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~geocatalog.aio.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`get_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def item_collections_collection_id_items_item_id_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, collection_id: str, item_id: str, **kwargs: Any
    ) -> None:
        """Get Item.

        Endpoint.

        :param collection_id: Collection ID. Required.
        :type collection_id: str
        :param item_id: Item ID. Required.
        :type item_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        accept: Literal["application/geo+json"] = kwargs.pop("accept", _headers.pop("accept", "application/geo+json"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_get_operations_item_collections_collection_id_items_item_id_get_request(
            collection_id=collection_id,
            item_id=item_id,
            accept=accept,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def collections_collections_get(  # pylint: disable=inconsistent-return-statements
        self, **kwargs: Any
    ) -> None:
        """Get Collections.

        Endpoint.

        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_get_operations_collections_collections_get_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def collection_collections_collection_id_get(  # pylint: disable=inconsistent-return-statements
        self, collection_id: str, **kwargs: Any
    ) -> None:
        """Get Collection.

        Endpoint.

        :param collection_id: Collection ID. Required.
        :type collection_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_get_operations_collection_collections_collection_id_get_request(
            collection_id=collection_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def item_collection_collections_collection_id_items_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        collection_id: str,
        *,
        limit: Optional[int] = None,
        bbox: Optional[str] = None,
        datetime: Optional[str] = None,
        token: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """Get Itemcollection.

        Endpoint.

        :param collection_id: Collection ID. Required.
        :type collection_id: str
        :keyword limit: Default value is None.
        :paramtype limit: int
        :keyword bbox: Default value is None.
        :paramtype bbox: str
        :keyword datetime: Default value is None.
        :paramtype datetime: str
        :keyword token: Default value is None.
        :paramtype token: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        accept: Literal["application/geo+json"] = kwargs.pop("accept", _headers.pop("accept", "application/geo+json"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_get_operations_item_collection_collections_collection_id_items_get_request(
            collection_id=collection_id,
            limit=limit,
            bbox=bbox,
            datetime=datetime,
            token=token,
            accept=accept,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class UpdateOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~geocatalog.aio.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`update_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def item_collections_collection_id_items_item_id_put(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        collection_id: str,
        item_id: str,
        body: Optional[_models.Item] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Update Item.

        Endpoint.

        :param collection_id: Collection ID. Required.
        :type collection_id: str
        :param item_id: Item ID. Required.
        :type item_id: str
        :param body: Default value is None.
        :type body: ~geocatalog.models.Item
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "assets": {
                        "str": {}
                    },
                    "bbox": [
                        {}
                    ],
                    "collection": "str",
                    "geometry": {
                        "str": {}
                    },
                    "id": "str",
                    "links": [
                        {
                            "str": {}
                        }
                    ],
                    "properties": {
                        "str": {}
                    },
                    "stac_extensions": [
                        "str"
                    ],
                    "stac_version": "str",
                    "type": "str"
                }
        """

    @overload
    async def item_collections_collection_id_items_item_id_put(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        collection_id: str,
        item_id: str,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Update Item.

        Endpoint.

        :param collection_id: Collection ID. Required.
        :type collection_id: str
        :param item_id: Item ID. Required.
        :type item_id: str
        :param body: Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def item_collections_collection_id_items_item_id_put(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        collection_id: str,
        item_id: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Update Item.

        Endpoint.

        :param collection_id: Collection ID. Required.
        :type collection_id: str
        :param item_id: Item ID. Required.
        :type item_id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def item_collections_collection_id_items_item_id_put(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        collection_id: str,
        item_id: str,
        body: Optional[Union[_models.Item, JSON, IO[bytes]]] = None,
        **kwargs: Any
    ) -> None:
        """Update Item.

        Endpoint.

        :param collection_id: Collection ID. Required.
        :type collection_id: str
        :param item_id: Item ID. Required.
        :type item_id: str
        :param body: Is one of the following types: Item, JSON, IO[bytes] Default value is None.
        :type body: ~geocatalog.models.Item or JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "assets": {
                        "str": {}
                    },
                    "bbox": [
                        {}
                    ],
                    "collection": "str",
                    "geometry": {
                        "str": {}
                    },
                    "id": "str",
                    "links": [
                        {
                            "str": {}
                        }
                    ],
                    "properties": {
                        "str": {}
                    },
                    "stac_extensions": [
                        "str"
                    ],
                    "stac_version": "str",
                    "type": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
            else:
                _content = None

        _request = build_update_operations_item_collections_collection_id_items_item_id_put_request(
            collection_id=collection_id,
            item_id=item_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def collection_collections_put(  # pylint: disable=inconsistent-return-statements
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Update Collection.

        Endpoint.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}
        """

    @overload
    async def collection_collections_put(  # pylint: disable=inconsistent-return-statements
        self, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Update Collection.

        Endpoint.

        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def collection_collections_put(  # pylint: disable=inconsistent-return-statements
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Update Collection.

        Endpoint.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def collection_collections_put(  # pylint: disable=inconsistent-return-statements
        self, body: Union[JSON, IO[bytes]] = _Unset, **kwargs: Any
    ) -> None:
        """Update Collection.

        Endpoint.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_update_operations_collection_collections_put_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class DeleteOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~geocatalog.aio.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`delete_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def item_collections_collection_id_items_item_id_delete(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, collection_id: str, item_id: str, **kwargs: Any
    ) -> None:
        """Delete Item.

        Endpoint.

        :param collection_id: Collection ID. Required.
        :type collection_id: str
        :param item_id: Item ID. Required.
        :type item_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_delete_operations_item_collections_collection_id_items_item_id_delete_request(
            collection_id=collection_id,
            item_id=item_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def collection_collections_collection_id_delete(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, collection_id: str, **kwargs: Any
    ) -> None:
        """Delete Collection.

        Endpoint.

        :param collection_id: Collection ID. Required.
        :type collection_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_delete_operations_collection_collections_collection_id_delete_request(
            collection_id=collection_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class SearchOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~geocatalog.aio.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`search_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def search_get(  # pylint: disable=inconsistent-return-statements
        self,
        *,
        collections: Optional[str] = None,
        ids: Optional[str] = None,
        bbox: Optional[str] = None,
        intersects: Optional[str] = None,
        datetime: Optional[str] = None,
        limit: Optional[int] = None,
        query: Optional[str] = None,
        sortby: Optional[str] = None,
        fields: Optional[str] = None,
        filter: Optional[str] = None,
        token: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """Search.

        Endpoint.

        :keyword collections: Default value is None.
        :paramtype collections: str
        :keyword ids: Default value is None.
        :paramtype ids: str
        :keyword bbox: Default value is None.
        :paramtype bbox: str
        :keyword intersects: Default value is None.
        :paramtype intersects: str
        :keyword datetime: Default value is None.
        :paramtype datetime: str
        :keyword limit: Default value is None.
        :paramtype limit: int
        :keyword query: Default value is None.
        :paramtype query: str
        :keyword sortby: Default value is None.
        :paramtype sortby: str
        :keyword fields: Default value is None.
        :paramtype fields: str
        :keyword filter: Default value is None.
        :paramtype filter: str
        :keyword token: Default value is None.
        :paramtype token: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        accept: Literal["application/geo+json"] = kwargs.pop("accept", _headers.pop("accept", "application/geo+json"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_search_operations_search_get_request(
            collections=collections,
            ids=ids,
            bbox=bbox,
            intersects=intersects,
            datetime=datetime,
            limit=limit,
            query=query,
            sortby=sortby,
            fields=fields,
            filter=filter,
            token=token,
            accept=accept,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def search_post(  # pylint: disable=inconsistent-return-statements
        self, body: _models.SearchPostRequest, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Search.

        Endpoint.

        :param body: Required.
        :type body: ~geocatalog.models.SearchPostRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "bbox": {},
                    "collections": [
                        "str"
                    ],
                    "conf": {
                        "str": {}
                    },
                    "datetime": "str",
                    "fields": [
                        {
                            "exclude": [
                                "str"
                            ],
                            "include": [
                                "str"
                            ]
                        }
                    ],
                    "filter": {
                        "str": {}
                    },
                    "filter-crs": "str",
                    "filter-lang": "str",
                    "ids": [
                        "str"
                    ],
                    "intersects": {},
                    "limit": 0,
                    "query": {
                        "str": {
                            "str": {}
                        }
                    },
                    "sortby": [
                        {
                            "direction": "str",
                            "field": "str"
                        }
                    ],
                    "token": "str"
                }
        """

    @overload
    async def search_post(  # pylint: disable=inconsistent-return-statements
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Search.

        Endpoint.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def search_post(  # pylint: disable=inconsistent-return-statements
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Search.

        Endpoint.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def search_post(  # pylint: disable=inconsistent-return-statements
        self, body: Union[_models.SearchPostRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> None:
        """Search.

        Endpoint.

        :param body: Is one of the following types: SearchPostRequest, JSON, IO[bytes] Required.
        :type body: ~geocatalog.models.SearchPostRequest or JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "bbox": {},
                    "collections": [
                        "str"
                    ],
                    "conf": {
                        "str": {}
                    },
                    "datetime": "str",
                    "fields": [
                        {
                            "exclude": [
                                "str"
                            ],
                            "include": [
                                "str"
                            ]
                        }
                    ],
                    "filter": {
                        "str": {}
                    },
                    "filter-crs": "str",
                    "filter-lang": "str",
                    "ids": [
                        "str"
                    ],
                    "intersects": {},
                    "limit": 0,
                    "query": {
                        "str": {
                            "str": {}
                        }
                    },
                    "sortby": [
                        {
                            "direction": "str",
                            "field": "str"
                        }
                    ],
                    "token": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        accept: Literal["application/geo+json"] = kwargs.pop("accept", _headers.pop("accept", "application/geo+json"))
        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_search_operations_search_post_request(
            accept=accept,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class CreateOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~geocatalog.aio.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`create_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def collection_collections_post(  # pylint: disable=inconsistent-return-statements
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Create Collection.

        Endpoint.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}
        """

    @overload
    async def collection_collections_post(  # pylint: disable=inconsistent-return-statements
        self, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Create Collection.

        Endpoint.

        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def collection_collections_post(  # pylint: disable=inconsistent-return-statements
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Create Collection.

        Endpoint.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def collection_collections_post(  # pylint: disable=inconsistent-return-statements
        self, body: Union[JSON, IO[bytes]] = _Unset, **kwargs: Any
    ) -> None:
        """Create Collection.

        Endpoint.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_create_operations_collection_collections_post_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def item_collections_collection_id_items_post(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        collection_id: str,
        body: Optional[_models.Item0] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Create Item.

        Endpoint.

        :param collection_id: Collection ID. Required.
        :type collection_id: str
        :param body: Default value is None.
        :type body: ~geocatalog.models.Item0
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}
        """

    @overload
    async def item_collections_collection_id_items_post(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, collection_id: str, body: Optional[JSON] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Create Item.

        Endpoint.

        :param collection_id: Collection ID. Required.
        :type collection_id: str
        :param body: Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def item_collections_collection_id_items_post(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        collection_id: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Create Item.

        Endpoint.

        :param collection_id: Collection ID. Required.
        :type collection_id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def item_collections_collection_id_items_post(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, collection_id: str, body: Optional[Union[_models.Item0, JSON, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """Create Item.

        Endpoint.

        :param collection_id: Collection ID. Required.
        :type collection_id: str
        :param body: Is one of the following types: Item0, JSON, IO[bytes] Default value is None.
        :type body: ~geocatalog.models.Item0 or JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
            else:
                _content = None

        _request = build_create_operations_item_collections_collection_id_items_post_request(
            collection_id=collection_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class QueryablesOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~geocatalog.aio.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`queryables_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def queryables_get(self, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Queryables.

        Endpoint.

        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_queryables_operations_queryables_get_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class CollectionOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~geocatalog.aio.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`collection_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def queryables_collections_collection_id_queryables_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, collection_id: str, **kwargs: Any
    ) -> None:
        """Collection Queryables.

        Endpoint.

        :param collection_id: Collection ID. Required.
        :type collection_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_collection_operations_queryables_collections_collection_id_queryables_get_request(
            collection_id=collection_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class boundsOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~geocatalog.aio.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`bounds_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def item_bounds_get(self, *, collection: str, item: str, **kwargs: Any) -> _models.Bounds:
        """Bounds.

        Return the bounds of the COG.

        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :return: Bounds. The Bounds is compatible with MutableMapping
        :rtype: ~geocatalog.models.Bounds
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "bounds": [
                        {}
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Bounds] = kwargs.pop("cls", None)

        _request = build_bounds_operations_item_bounds_get_request(
            collection=collection,
            item=item,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Bounds, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class infoOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~geocatalog.aio.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`info_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def item_info_get(  # pylint: disable=inconsistent-return-statements
        self, *, collection: str, item: str, assets: Optional[List[str]] = None, **kwargs: Any
    ) -> None:
        """Info.

        Return dataset's basic info or the list of available assets.

        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_info_operations_item_info_get_request(
            collection=collection,
            item=item,
            assets=assets,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def geojson_item_info_geojson_get(
        self, *, collection: str, item: str, assets: Optional[List[str]] = None, **kwargs: Any
    ) -> _models.FeaturePolygonDictStrRioTilerModelsInfo:
        """Info Geojson.

        Return dataset's basic info as a GeoJSON feature.

        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :return: FeaturePolygonDictStrRioTilerModelsInfo. The FeaturePolygonDictStrRioTilerModelsInfo
         is compatible with MutableMapping
        :rtype: ~geocatalog.models.FeaturePolygonDictStrRioTilerModelsInfo
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "bbox": {},
                    "geometry": {
                        "coordinates": [
                            [
                                {}
                            ]
                        ],
                        "bbox": {},
                        "type": "str"
                    },
                    "id": "str",
                    "properties": {
                        "str": {
                            "band_descriptions": [
                                [
                                    "str"
                                ]
                            ],
                            "band_metadata": [
                                [
                                    "str"
                                ]
                            ],
                            "bounds": [
                                {}
                            ],
                            "dtype": "str",
                            "maxzoom": 0,
                            "minzoom": 0,
                            "nodata_type": "str",
                            "colorinterp": [
                                "str"
                            ],
                            "colormap": {
                                "str": [
                                    0
                                ]
                            },
                            "offset": 0.0,
                            "scale": 0.0
                        }
                    },
                    "type": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        accept: Literal["application/geo+json"] = kwargs.pop("accept", _headers.pop("accept", "application/geo+json"))
        cls: ClsType[_models.FeaturePolygonDictStrRioTilerModelsInfo] = kwargs.pop("cls", None)

        _request = build_info_operations_geojson_item_info_geojson_get_request(
            collection=collection,
            item=item,
            assets=assets,
            accept=accept,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FeaturePolygonDictStrRioTilerModelsInfo, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def search_mosaic_searchid_info_get(self, searchid: str, **kwargs: Any) -> _models.TitilerPgstacModelInfo:
        """Info Search.

        Get Search query metadata.

        :param searchid: Search Id. Required.
        :type searchid: str
        :return: TitilerPgstacModelInfo. The TitilerPgstacModelInfo is compatible with MutableMapping
        :rtype: ~geocatalog.models.TitilerPgstacModelInfo
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "search": {
                        "_where": "str",
                        "hash": "str",
                        "lastused": "2020-02-20 00:00:00",
                        "metadata": {
                            "assets": [
                                "str"
                            ],
                            "bounds": {},
                            "defaults": {
                                "str": {}
                            },
                            "maxzoom": 0,
                            "minzoom": 0,
                            "name": "str",
                            "type": "str"
                        },
                        "orderby": "str",
                        "search": {
                            "str": {}
                        },
                        "usecount": 0
                    },
                    "links": [
                        {
                            "href": "str",
                            "hreflang": "str",
                            "length": 0,
                            "rel": "str",
                            "title": "str",
                            "type": "str"
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TitilerPgstacModelInfo] = kwargs.pop("cls", None)

        _request = build_info_operations_search_mosaic_searchid_info_get_request(
            searchid=searchid,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TitilerPgstacModelInfo, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class availableOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~geocatalog.aio.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`available_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def assets_item_assets_get(  # pylint: disable=inconsistent-return-statements
        self, *, collection: str, item: str, **kwargs: Any
    ) -> None:
        """Available Assets.

        Return a list of supported assets.

        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_available_operations_assets_item_assets_get_request(
            collection=collection,
            item=item,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class assetOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~geocatalog.aio.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`asset_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def statistics_item_asset_statistics_get(  # pylint: disable=inconsistent-return-statements
        self,
        *,
        collection: str,
        item: str,
        assets: Optional[List[str]] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_expression: Optional[List[str]] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Paths1E8Q8EeDataItemAssetStatisticsGetParameters7Schema]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        categorical: Optional[bool] = None,
        c: Optional[List[Any]] = None,
        p: Optional[List[int]] = None,
        histogram_bins: Optional[str] = None,
        histogram_range: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """Asset Statistics.

        Per Asset statistics.

        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_expression: Per asset band expression. Default value is None.
        :paramtype asset_expression: list[str]
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths1E8Q8EeDataItemAssetStatisticsGetParameters7Schema
        :keyword max_size: Maximum image size to read onto. Default value is None.
        :paramtype max_size: int
        :keyword height: Force output image height. Default value is None.
        :paramtype height: int
        :keyword width: Force output image width. Default value is None.
        :paramtype width: int
        :keyword categorical: Return statistics for categorical dataset. Default value is None.
        :paramtype categorical: bool
        :keyword c: List of values for which to report counts. Default value is None.
        :paramtype c: list[any]
        :keyword p: List of percentile values. Default value is None.
        :paramtype p: list[int]
        :keyword histogram_bins: Defines the number of equal-width bins in the given range (10, by
         default).

         If bins is a sequence (comma ``,`` delimited values), it defines a monotonically
         increasing array of bin edges, including the rightmost edge, allowing for
         non-uniform bin widths.

         link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html. Default value is
         None.
        :paramtype histogram_bins: str
        :keyword histogram_range: Comma ``,`` delimited range of the bins.

         The lower and upper range of the bins. If not provided, range is simply
         (a.min(), a.max()).

         Values outside the range are ignored. The first element of the range must be
         less than or equal to the second.
         range affects the automatic bin computation as well.

         link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html. Default value is
         None.
        :paramtype histogram_range: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_asset_operations_statistics_item_asset_statistics_get_request(
            collection=collection,
            item=item,
            assets=assets,
            asset_bidx=asset_bidx,
            asset_expression=asset_expression,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            max_size=max_size,
            height=height,
            width=width,
            categorical=categorical,
            c=c,
            p=p,
            histogram_bins=histogram_bins,
            histogram_range=histogram_range,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class statisticsOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~geocatalog.aio.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`statistics_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def item_statistics_get(  # pylint: disable=inconsistent-return-statements
        self,
        *,
        collection: str,
        item: str,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.PathsHkjof3DataItemStatisticsGetParameters8Schema]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        categorical: Optional[bool] = None,
        c: Optional[List[Any]] = None,
        p: Optional[List[int]] = None,
        histogram_bins: Optional[str] = None,
        histogram_range: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """Statistics.

        Merged assets statistics.

        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.PathsHkjof3DataItemStatisticsGetParameters8Schema
        :keyword max_size: Maximum image size to read onto. Default value is None.
        :paramtype max_size: int
        :keyword height: Force output image height. Default value is None.
        :paramtype height: int
        :keyword width: Force output image width. Default value is None.
        :paramtype width: int
        :keyword categorical: Return statistics for categorical dataset. Default value is None.
        :paramtype categorical: bool
        :keyword c: List of values for which to report counts. Default value is None.
        :paramtype c: list[any]
        :keyword p: List of percentile values. Default value is None.
        :paramtype p: list[int]
        :keyword histogram_bins: Defines the number of equal-width bins in the given range (10, by
         default).

         If bins is a sequence (comma ``,`` delimited values), it defines a monotonically
         increasing array of bin edges, including the rightmost edge, allowing for
         non-uniform bin widths.

         link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html. Default value is
         None.
        :paramtype histogram_bins: str
        :keyword histogram_range: Comma ``,`` delimited range of the bins.

         The lower and upper range of the bins. If not provided, range is simply
         (a.min(), a.max()).

         Values outside the range are ignored. The first element of the range must be
         less than or equal to the second.
         range affects the automatic bin computation as well.

         link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html. Default value is
         None.
        :paramtype histogram_range: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_statistics_operations_item_statistics_get_request(
            collection=collection,
            item=item,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            max_size=max_size,
            height=height,
            width=width,
            categorical=categorical,
            c=c,
            p=p,
            histogram_bins=histogram_bins,
            histogram_range=histogram_range,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class geojsonOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~geocatalog.aio.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`geojson_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def statistics_item_statistics_post(  # pylint: disable=inconsistent-return-statements
        self,
        body: _models.Geojson,
        *,
        collection: str,
        item: str,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Paths1ApbtvyDataItemStatisticsPostParameters8Schema]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        categorical: Optional[bool] = None,
        c: Optional[List[Any]] = None,
        p: Optional[List[int]] = None,
        histogram_bins: Optional[str] = None,
        histogram_range: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Geojson Statistics.

        Get Statistics from a geojson feature or featureCollection.

        :param body: Required.
        :type body: ~geocatalog.models.Geojson
        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths1ApbtvyDataItemStatisticsPostParameters8Schema
        :keyword max_size: Maximum image size to read onto. Default value is None.
        :paramtype max_size: int
        :keyword height: Force output image height. Default value is None.
        :paramtype height: int
        :keyword width: Force output image width. Default value is None.
        :paramtype width: int
        :keyword categorical: Return statistics for categorical dataset. Default value is None.
        :paramtype categorical: bool
        :keyword c: List of values for which to report counts. Default value is None.
        :paramtype c: list[any]
        :keyword p: List of percentile values. Default value is None.
        :paramtype p: list[int]
        :keyword histogram_bins: Defines the number of equal-width bins in the given range (10, by
         default).

         If bins is a sequence (comma ``,`` delimited values), it defines a monotonically
         increasing array of bin edges, including the rightmost edge, allowing for
         non-uniform bin widths.

         link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html. Default value is
         None.
        :paramtype histogram_bins: str
        :keyword histogram_range: Comma ``,`` delimited range of the bins.

         The lower and upper range of the bins. If not provided, range is simply
         (a.min(), a.max()).

         Values outside the range are ignored. The first element of the range must be
         less than or equal to the second.
         range affects the automatic bin computation as well.

         link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html. Default value is
         None.
        :paramtype histogram_range: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}
        """

    @overload
    async def statistics_item_statistics_post(  # pylint: disable=inconsistent-return-statements
        self,
        body: JSON,
        *,
        collection: str,
        item: str,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Paths1ApbtvyDataItemStatisticsPostParameters8Schema]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        categorical: Optional[bool] = None,
        c: Optional[List[Any]] = None,
        p: Optional[List[int]] = None,
        histogram_bins: Optional[str] = None,
        histogram_range: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Geojson Statistics.

        Get Statistics from a geojson feature or featureCollection.

        :param body: Required.
        :type body: JSON
        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths1ApbtvyDataItemStatisticsPostParameters8Schema
        :keyword max_size: Maximum image size to read onto. Default value is None.
        :paramtype max_size: int
        :keyword height: Force output image height. Default value is None.
        :paramtype height: int
        :keyword width: Force output image width. Default value is None.
        :paramtype width: int
        :keyword categorical: Return statistics for categorical dataset. Default value is None.
        :paramtype categorical: bool
        :keyword c: List of values for which to report counts. Default value is None.
        :paramtype c: list[any]
        :keyword p: List of percentile values. Default value is None.
        :paramtype p: list[int]
        :keyword histogram_bins: Defines the number of equal-width bins in the given range (10, by
         default).

         If bins is a sequence (comma ``,`` delimited values), it defines a monotonically
         increasing array of bin edges, including the rightmost edge, allowing for
         non-uniform bin widths.

         link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html. Default value is
         None.
        :paramtype histogram_bins: str
        :keyword histogram_range: Comma ``,`` delimited range of the bins.

         The lower and upper range of the bins. If not provided, range is simply
         (a.min(), a.max()).

         Values outside the range are ignored. The first element of the range must be
         less than or equal to the second.
         range affects the automatic bin computation as well.

         link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html. Default value is
         None.
        :paramtype histogram_range: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def statistics_item_statistics_post(  # pylint: disable=inconsistent-return-statements
        self,
        body: IO[bytes],
        *,
        collection: str,
        item: str,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Paths1ApbtvyDataItemStatisticsPostParameters8Schema]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        categorical: Optional[bool] = None,
        c: Optional[List[Any]] = None,
        p: Optional[List[int]] = None,
        histogram_bins: Optional[str] = None,
        histogram_range: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Geojson Statistics.

        Get Statistics from a geojson feature or featureCollection.

        :param body: Required.
        :type body: IO[bytes]
        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths1ApbtvyDataItemStatisticsPostParameters8Schema
        :keyword max_size: Maximum image size to read onto. Default value is None.
        :paramtype max_size: int
        :keyword height: Force output image height. Default value is None.
        :paramtype height: int
        :keyword width: Force output image width. Default value is None.
        :paramtype width: int
        :keyword categorical: Return statistics for categorical dataset. Default value is None.
        :paramtype categorical: bool
        :keyword c: List of values for which to report counts. Default value is None.
        :paramtype c: list[any]
        :keyword p: List of percentile values. Default value is None.
        :paramtype p: list[int]
        :keyword histogram_bins: Defines the number of equal-width bins in the given range (10, by
         default).

         If bins is a sequence (comma ``,`` delimited values), it defines a monotonically
         increasing array of bin edges, including the rightmost edge, allowing for
         non-uniform bin widths.

         link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html. Default value is
         None.
        :paramtype histogram_bins: str
        :keyword histogram_range: Comma ``,`` delimited range of the bins.

         The lower and upper range of the bins. If not provided, range is simply
         (a.min(), a.max()).

         Values outside the range are ignored. The first element of the range must be
         less than or equal to the second.
         range affects the automatic bin computation as well.

         link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html. Default value is
         None.
        :paramtype histogram_range: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def statistics_item_statistics_post(  # pylint: disable=inconsistent-return-statements
        self,
        body: Union[_models.Geojson, JSON, IO[bytes]],
        *,
        collection: str,
        item: str,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Paths1ApbtvyDataItemStatisticsPostParameters8Schema]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        categorical: Optional[bool] = None,
        c: Optional[List[Any]] = None,
        p: Optional[List[int]] = None,
        histogram_bins: Optional[str] = None,
        histogram_range: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """Geojson Statistics.

        Get Statistics from a geojson feature or featureCollection.

        :param body: Is one of the following types: Geojson, JSON, IO[bytes] Required.
        :type body: ~geocatalog.models.Geojson or JSON or IO[bytes]
        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths1ApbtvyDataItemStatisticsPostParameters8Schema
        :keyword max_size: Maximum image size to read onto. Default value is None.
        :paramtype max_size: int
        :keyword height: Force output image height. Default value is None.
        :paramtype height: int
        :keyword width: Force output image width. Default value is None.
        :paramtype width: int
        :keyword categorical: Return statistics for categorical dataset. Default value is None.
        :paramtype categorical: bool
        :keyword c: List of values for which to report counts. Default value is None.
        :paramtype c: list[any]
        :keyword p: List of percentile values. Default value is None.
        :paramtype p: list[int]
        :keyword histogram_bins: Defines the number of equal-width bins in the given range (10, by
         default).

         If bins is a sequence (comma ``,`` delimited values), it defines a monotonically
         increasing array of bin edges, including the rightmost edge, allowing for
         non-uniform bin widths.

         link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html. Default value is
         None.
        :paramtype histogram_bins: str
        :keyword histogram_range: Comma ``,`` delimited range of the bins.

         The lower and upper range of the bins. If not provided, range is simply
         (a.min(), a.max()).

         Values outside the range are ignored. The first element of the range must be
         less than or equal to the second.
         range affects the automatic bin computation as well.

         link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html. Default value is
         None.
        :paramtype histogram_range: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        accept: Literal["application/geo+json, application/json"] = kwargs.pop(
            "accept", _headers.pop("accept", "application/geo+json, application/json")
        )
        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_geojson_operations_statistics_item_statistics_post_request(
            collection=collection,
            item=item,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            max_size=max_size,
            height=height,
            width=width,
            categorical=categorical,
            c=c,
            p=p,
            histogram_bins=histogram_bins,
            histogram_range=histogram_range,
            accept=accept,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def crop_item_crop_width_x_height_format_post(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        format: Union[str, _models.ImageType16],
        height: int,
        width: int,
        body: _models.Geojson0,
        *,
        collection: str,
        item: str,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[
            Union[str, _models.Paths1V2SkjcDataItemCropWidthXHeightFormatPostParameters12Schema]
        ] = None,
        max_size: Optional[int] = None,
        algorithm: Optional[Union[str, _models.Algorithm15]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[
            Union[str, _models.Paths114M1TgDataItemCropWidthXHeightFormatPostParameters17Schema]
        ] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Geojson Crop.

        Create image from a geojson feature.

        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~geocatalog.models.ImageType16
        :param height: Required.
        :type height: int
        :param width: Required.
        :type width: int
        :param body: Required.
        :type body: ~geocatalog.models.Geojson0
        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths1V2SkjcDataItemCropWidthXHeightFormatPostParameters12Schema
        :keyword max_size: Maximum image size to read onto. Default value is None.
        :paramtype max_size: int
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm15
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.Paths114M1TgDataItemCropWidthXHeightFormatPostParameters17Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "bbox": {},
                    "geometry": {},
                    "id": "str",
                    "properties": {
                        "str": {}
                    },
                    "type": "str"
                }
        """

    @overload
    async def crop_item_crop_width_x_height_format_post(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        format: Union[str, _models.ImageType16],
        height: int,
        width: int,
        body: JSON,
        *,
        collection: str,
        item: str,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[
            Union[str, _models.Paths1V2SkjcDataItemCropWidthXHeightFormatPostParameters12Schema]
        ] = None,
        max_size: Optional[int] = None,
        algorithm: Optional[Union[str, _models.Algorithm15]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[
            Union[str, _models.Paths114M1TgDataItemCropWidthXHeightFormatPostParameters17Schema]
        ] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Geojson Crop.

        Create image from a geojson feature.

        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~geocatalog.models.ImageType16
        :param height: Required.
        :type height: int
        :param width: Required.
        :type width: int
        :param body: Required.
        :type body: JSON
        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths1V2SkjcDataItemCropWidthXHeightFormatPostParameters12Schema
        :keyword max_size: Maximum image size to read onto. Default value is None.
        :paramtype max_size: int
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm15
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.Paths114M1TgDataItemCropWidthXHeightFormatPostParameters17Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def crop_item_crop_width_x_height_format_post(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        format: Union[str, _models.ImageType16],
        height: int,
        width: int,
        body: IO[bytes],
        *,
        collection: str,
        item: str,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[
            Union[str, _models.Paths1V2SkjcDataItemCropWidthXHeightFormatPostParameters12Schema]
        ] = None,
        max_size: Optional[int] = None,
        algorithm: Optional[Union[str, _models.Algorithm15]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[
            Union[str, _models.Paths114M1TgDataItemCropWidthXHeightFormatPostParameters17Schema]
        ] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Geojson Crop.

        Create image from a geojson feature.

        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~geocatalog.models.ImageType16
        :param height: Required.
        :type height: int
        :param width: Required.
        :type width: int
        :param body: Required.
        :type body: IO[bytes]
        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths1V2SkjcDataItemCropWidthXHeightFormatPostParameters12Schema
        :keyword max_size: Maximum image size to read onto. Default value is None.
        :paramtype max_size: int
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm15
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.Paths114M1TgDataItemCropWidthXHeightFormatPostParameters17Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def crop_item_crop_width_x_height_format_post(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        format: Union[str, _models.ImageType16],
        height: int,
        width: int,
        body: Union[_models.Geojson0, JSON, IO[bytes]],
        *,
        collection: str,
        item: str,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[
            Union[str, _models.Paths1V2SkjcDataItemCropWidthXHeightFormatPostParameters12Schema]
        ] = None,
        max_size: Optional[int] = None,
        algorithm: Optional[Union[str, _models.Algorithm15]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[
            Union[str, _models.Paths114M1TgDataItemCropWidthXHeightFormatPostParameters17Schema]
        ] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Geojson Crop.

        Create image from a geojson feature.

        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~geocatalog.models.ImageType16
        :param height: Required.
        :type height: int
        :param width: Required.
        :type width: int
        :param body: Is one of the following types: Geojson0, JSON, IO[bytes] Required.
        :type body: ~geocatalog.models.Geojson0 or JSON or IO[bytes]
        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths1V2SkjcDataItemCropWidthXHeightFormatPostParameters12Schema
        :keyword max_size: Maximum image size to read onto. Default value is None.
        :paramtype max_size: int
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm15
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.Paths114M1TgDataItemCropWidthXHeightFormatPostParameters17Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "bbox": {},
                    "geometry": {},
                    "id": "str",
                    "properties": {
                        "str": {}
                    },
                    "type": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_geojson_operations_crop_item_crop_width_x_height_format_post_request(
            format=format,
            height=height,
            width=width,
            collection=collection,
            item=item,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            max_size=max_size,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def crop_item_crop_format_post(  # pylint: disable=inconsistent-return-statements
        self,
        format: Union[str, _models.ImageType17],
        body: _models.Geojson1,
        *,
        collection: str,
        item: str,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Paths183C7Q5DataItemCropFormatPostParameters10Schema]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        algorithm: Optional[Union[str, _models.Algorithm16]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.Paths2Kw62GDataItemCropFormatPostParameters17Schema]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Geojson Crop.

        Create image from a geojson feature.

        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~geocatalog.models.ImageType17
        :param body: Required.
        :type body: ~geocatalog.models.Geojson1
        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths183C7Q5DataItemCropFormatPostParameters10Schema
        :keyword max_size: Maximum image size to read onto. Default value is None.
        :paramtype max_size: int
        :keyword height: Force output image height. Default value is None.
        :paramtype height: int
        :keyword width: Force output image width. Default value is None.
        :paramtype width: int
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm16
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.Paths2Kw62GDataItemCropFormatPostParameters17Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "bbox": {},
                    "geometry": {},
                    "id": "str",
                    "properties": {
                        "str": {}
                    },
                    "type": "str"
                }
        """

    @overload
    async def crop_item_crop_format_post(  # pylint: disable=inconsistent-return-statements
        self,
        format: Union[str, _models.ImageType17],
        body: JSON,
        *,
        collection: str,
        item: str,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Paths183C7Q5DataItemCropFormatPostParameters10Schema]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        algorithm: Optional[Union[str, _models.Algorithm16]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.Paths2Kw62GDataItemCropFormatPostParameters17Schema]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Geojson Crop.

        Create image from a geojson feature.

        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~geocatalog.models.ImageType17
        :param body: Required.
        :type body: JSON
        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths183C7Q5DataItemCropFormatPostParameters10Schema
        :keyword max_size: Maximum image size to read onto. Default value is None.
        :paramtype max_size: int
        :keyword height: Force output image height. Default value is None.
        :paramtype height: int
        :keyword width: Force output image width. Default value is None.
        :paramtype width: int
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm16
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.Paths2Kw62GDataItemCropFormatPostParameters17Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def crop_item_crop_format_post(  # pylint: disable=inconsistent-return-statements
        self,
        format: Union[str, _models.ImageType17],
        body: IO[bytes],
        *,
        collection: str,
        item: str,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Paths183C7Q5DataItemCropFormatPostParameters10Schema]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        algorithm: Optional[Union[str, _models.Algorithm16]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.Paths2Kw62GDataItemCropFormatPostParameters17Schema]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Geojson Crop.

        Create image from a geojson feature.

        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~geocatalog.models.ImageType17
        :param body: Required.
        :type body: IO[bytes]
        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths183C7Q5DataItemCropFormatPostParameters10Schema
        :keyword max_size: Maximum image size to read onto. Default value is None.
        :paramtype max_size: int
        :keyword height: Force output image height. Default value is None.
        :paramtype height: int
        :keyword width: Force output image width. Default value is None.
        :paramtype width: int
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm16
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.Paths2Kw62GDataItemCropFormatPostParameters17Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def crop_item_crop_format_post(  # pylint: disable=inconsistent-return-statements
        self,
        format: Union[str, _models.ImageType17],
        body: Union[_models.Geojson1, JSON, IO[bytes]],
        *,
        collection: str,
        item: str,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Paths183C7Q5DataItemCropFormatPostParameters10Schema]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        algorithm: Optional[Union[str, _models.Algorithm16]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.Paths2Kw62GDataItemCropFormatPostParameters17Schema]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Geojson Crop.

        Create image from a geojson feature.

        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~geocatalog.models.ImageType17
        :param body: Is one of the following types: Geojson1, JSON, IO[bytes] Required.
        :type body: ~geocatalog.models.Geojson1 or JSON or IO[bytes]
        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths183C7Q5DataItemCropFormatPostParameters10Schema
        :keyword max_size: Maximum image size to read onto. Default value is None.
        :paramtype max_size: int
        :keyword height: Force output image height. Default value is None.
        :paramtype height: int
        :keyword width: Force output image width. Default value is None.
        :paramtype width: int
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm16
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.Paths2Kw62GDataItemCropFormatPostParameters17Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "bbox": {},
                    "geometry": {},
                    "id": "str",
                    "properties": {
                        "str": {}
                    },
                    "type": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_geojson_operations_crop_item_crop_format_post_request(
            format=format,
            collection=collection,
            item=item,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            max_size=max_size,
            height=height,
            width=width,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def crop_item_crop_post(  # pylint: disable=inconsistent-return-statements
        self,
        body: _models.Geojson2,
        *,
        collection: str,
        item: str,
        format: Optional[Union[str, _models.ImageType18]] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Paths1GbhpkuDataItemCropPostParameters10Schema]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        algorithm: Optional[Union[str, _models.Algorithm17]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.Paths1H72Th3DataItemCropPostParameters17Schema]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Geojson Crop.

        Create image from a geojson feature.

        :param body: Required.
        :type body: ~geocatalog.models.Geojson2
        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword format: Output image type. Default is auto. Known values are: "png", "npy", "tif",
         "jpeg", "jpg", "jp2", "webp", and "pngraw". Default value is None.
        :paramtype format: str or ~geocatalog.models.ImageType18
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or ~geocatalog.models.Paths1GbhpkuDataItemCropPostParameters10Schema
        :keyword max_size: Maximum image size to read onto. Default value is None.
        :paramtype max_size: int
        :keyword height: Force output image height. Default value is None.
        :paramtype height: int
        :keyword width: Force output image width. Default value is None.
        :paramtype width: int
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm17
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.Paths1H72Th3DataItemCropPostParameters17Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "bbox": {},
                    "geometry": {},
                    "id": "str",
                    "properties": {
                        "str": {}
                    },
                    "type": "str"
                }
        """

    @overload
    async def crop_item_crop_post(  # pylint: disable=inconsistent-return-statements
        self,
        body: JSON,
        *,
        collection: str,
        item: str,
        format: Optional[Union[str, _models.ImageType18]] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Paths1GbhpkuDataItemCropPostParameters10Schema]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        algorithm: Optional[Union[str, _models.Algorithm17]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.Paths1H72Th3DataItemCropPostParameters17Schema]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Geojson Crop.

        Create image from a geojson feature.

        :param body: Required.
        :type body: JSON
        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword format: Output image type. Default is auto. Known values are: "png", "npy", "tif",
         "jpeg", "jpg", "jp2", "webp", and "pngraw". Default value is None.
        :paramtype format: str or ~geocatalog.models.ImageType18
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or ~geocatalog.models.Paths1GbhpkuDataItemCropPostParameters10Schema
        :keyword max_size: Maximum image size to read onto. Default value is None.
        :paramtype max_size: int
        :keyword height: Force output image height. Default value is None.
        :paramtype height: int
        :keyword width: Force output image width. Default value is None.
        :paramtype width: int
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm17
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.Paths1H72Th3DataItemCropPostParameters17Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def crop_item_crop_post(  # pylint: disable=inconsistent-return-statements
        self,
        body: IO[bytes],
        *,
        collection: str,
        item: str,
        format: Optional[Union[str, _models.ImageType18]] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Paths1GbhpkuDataItemCropPostParameters10Schema]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        algorithm: Optional[Union[str, _models.Algorithm17]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.Paths1H72Th3DataItemCropPostParameters17Schema]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Geojson Crop.

        Create image from a geojson feature.

        :param body: Required.
        :type body: IO[bytes]
        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword format: Output image type. Default is auto. Known values are: "png", "npy", "tif",
         "jpeg", "jpg", "jp2", "webp", and "pngraw". Default value is None.
        :paramtype format: str or ~geocatalog.models.ImageType18
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or ~geocatalog.models.Paths1GbhpkuDataItemCropPostParameters10Schema
        :keyword max_size: Maximum image size to read onto. Default value is None.
        :paramtype max_size: int
        :keyword height: Force output image height. Default value is None.
        :paramtype height: int
        :keyword width: Force output image width. Default value is None.
        :paramtype width: int
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm17
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.Paths1H72Th3DataItemCropPostParameters17Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def crop_item_crop_post(  # pylint: disable=inconsistent-return-statements
        self,
        body: Union[_models.Geojson2, JSON, IO[bytes]],
        *,
        collection: str,
        item: str,
        format: Optional[Union[str, _models.ImageType18]] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Paths1GbhpkuDataItemCropPostParameters10Schema]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        algorithm: Optional[Union[str, _models.Algorithm17]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.Paths1H72Th3DataItemCropPostParameters17Schema]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Geojson Crop.

        Create image from a geojson feature.

        :param body: Is one of the following types: Geojson2, JSON, IO[bytes] Required.
        :type body: ~geocatalog.models.Geojson2 or JSON or IO[bytes]
        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword format: Output image type. Default is auto. Known values are: "png", "npy", "tif",
         "jpeg", "jpg", "jp2", "webp", and "pngraw". Default value is None.
        :paramtype format: str or ~geocatalog.models.ImageType18
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or ~geocatalog.models.Paths1GbhpkuDataItemCropPostParameters10Schema
        :keyword max_size: Maximum image size to read onto. Default value is None.
        :paramtype max_size: int
        :keyword height: Force output image height. Default value is None.
        :paramtype height: int
        :keyword width: Force output image width. Default value is None.
        :paramtype width: int
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm17
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.Paths1H72Th3DataItemCropPostParameters17Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "bbox": {},
                    "geometry": {},
                    "id": "str",
                    "properties": {
                        "str": {}
                    },
                    "type": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_geojson_operations_crop_item_crop_post_request(
            collection=collection,
            item=item,
            format=format,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            max_size=max_size,
            height=height,
            width=width,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class tileOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~geocatalog.aio.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`tile_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def item_tiles_tile_matrix_set_id_z_x_y_scale_x_format_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        z: int,
        x: int,
        y: int,
        tile_matrix_set_id: Union[str, _models.Tilematrixsetid],
        scale: int,
        format: Union[str, _models.ImageType0],
        *,
        collection: str,
        item: str,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[
            Union[str, _models.Paths1Ammmt8DataItemTilesTilematrixsetidZXYScaleXFormatGetParameters16Schema]
        ] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[
            Union[str, _models.Paths1Rxw8AyDataItemTilesTilematrixsetidZXYScaleXFormatGetParameters20Schema]
        ] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Tile.

        Create map tile from a dataset.

        :param z: TMS tiles's zoom level. Required.
        :type z: int
        :param x: TMS tiles's column. Required.
        :type x: int
        :param y: TMS tiles's row. Required.
        :type y: int
        :param tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000", "NZTM2000Quad", "UPSAntarcticWGS84Quad",
         "UPSArcticWGS84Quad", "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Required.
        :type tile_matrix_set_id: str or ~geocatalog.models.Tilematrixsetid
        :param scale: Required.
        :type scale: int
        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~geocatalog.models.ImageType0
        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths1Ammmt8DataItemTilesTilematrixsetidZXYScaleXFormatGetParameters16Schema
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.Paths1Rxw8AyDataItemTilesTilematrixsetidZXYScaleXFormatGetParameters20Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_tile_operations_item_tiles_tile_matrix_set_id_z_x_y_scale_x_format_get_request(
            z=z,
            x=x,
            y=y,
            tile_matrix_set_id=tile_matrix_set_id,
            scale=scale,
            format=format,
            collection=collection,
            item=item,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def item_tiles_tile_matrix_set_id_z_x_y_scale_x_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        z: int,
        x: int,
        y: int,
        tile_matrix_set_id: Union[str, _models.Tilematrixsetid0],
        scale: int,
        *,
        collection: str,
        item: str,
        format: Optional[Union[str, _models.ImageType1]] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[
            Union[str, _models.PathsQ3R0GwDataItemTilesTilematrixsetidZXYScaleXGetParameters16Schema]
        ] = None,
        algorithm: Optional[Union[str, _models.Algorithm0]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[
            Union[str, _models.PathsTx3MegDataItemTilesTilematrixsetidZXYScaleXGetParameters20Schema]
        ] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Tile.

        Create map tile from a dataset.

        :param z: TMS tiles's zoom level. Required.
        :type z: int
        :param x: TMS tiles's column. Required.
        :type x: int
        :param y: TMS tiles's row. Required.
        :type y: int
        :param tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000", "NZTM2000Quad", "UPSAntarcticWGS84Quad",
         "UPSArcticWGS84Quad", "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Required.
        :type tile_matrix_set_id: str or ~geocatalog.models.Tilematrixsetid0
        :param scale: Required.
        :type scale: int
        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword format: Output image type. Default is auto. Known values are: "png", "npy", "tif",
         "jpeg", "jpg", "jp2", "webp", and "pngraw". Default value is None.
        :paramtype format: str or ~geocatalog.models.ImageType1
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.PathsQ3R0GwDataItemTilesTilematrixsetidZXYScaleXGetParameters16Schema
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm0
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.PathsTx3MegDataItemTilesTilematrixsetidZXYScaleXGetParameters20Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_tile_operations_item_tiles_tile_matrix_set_id_z_x_y_scale_x_get_request(
            z=z,
            x=x,
            y=y,
            tile_matrix_set_id=tile_matrix_set_id,
            scale=scale,
            collection=collection,
            item=item,
            format=format,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def item_tiles_tile_matrix_set_id_z_x_y_format_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        z: int,
        x: int,
        y: int,
        tile_matrix_set_id: Union[str, _models.Tilematrixsetid1],
        format: Union[str, _models.ImageType2],
        *,
        collection: str,
        item: str,
        scale: Optional[int] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[
            Union[str, _models.Paths1Oo93SwDataItemTilesTilematrixsetidZXYFormatGetParameters16Schema]
        ] = None,
        algorithm: Optional[Union[str, _models.Algorithm1]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[
            Union[str, _models.Paths18Ti1QuDataItemTilesTilematrixsetidZXYFormatGetParameters20Schema]
        ] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Tile.

        Create map tile from a dataset.

        :param z: TMS tiles's zoom level. Required.
        :type z: int
        :param x: TMS tiles's column. Required.
        :type x: int
        :param y: TMS tiles's row. Required.
        :type y: int
        :param tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000", "NZTM2000Quad", "UPSAntarcticWGS84Quad",
         "UPSArcticWGS84Quad", "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Required.
        :type tile_matrix_set_id: str or ~geocatalog.models.Tilematrixsetid1
        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~geocatalog.models.ImageType2
        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword scale: Tile size scale. 1=256x256, 2=512x512... Default value is None.
        :paramtype scale: int
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths1Oo93SwDataItemTilesTilematrixsetidZXYFormatGetParameters16Schema
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm1
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.Paths18Ti1QuDataItemTilesTilematrixsetidZXYFormatGetParameters20Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_tile_operations_item_tiles_tile_matrix_set_id_z_x_y_format_get_request(
            z=z,
            x=x,
            y=y,
            tile_matrix_set_id=tile_matrix_set_id,
            format=format,
            collection=collection,
            item=item,
            scale=scale,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def item_tiles_tile_matrix_set_id_z_x_y_get(  # pylint: disable=inconsistent-return-statements
        self,
        z: int,
        x: int,
        y: int,
        tile_matrix_set_id: Union[str, _models.Tilematrixsetid2],
        *,
        collection: str,
        item: str,
        scale: Optional[int] = None,
        format: Optional[Union[str, _models.ImageType3]] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[
            Union[str, _models.PathsS0Ema9DataItemTilesTilematrixsetidZXYGetParameters16Schema]
        ] = None,
        algorithm: Optional[Union[str, _models.Algorithm2]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[
            Union[str, _models.PathsT3AhfDataItemTilesTilematrixsetidZXYGetParameters20Schema]
        ] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Tile.

        Create map tile from a dataset.

        :param z: TMS tiles's zoom level. Required.
        :type z: int
        :param x: TMS tiles's column. Required.
        :type x: int
        :param y: TMS tiles's row. Required.
        :type y: int
        :param tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000", "NZTM2000Quad", "UPSAntarcticWGS84Quad",
         "UPSArcticWGS84Quad", "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Required.
        :type tile_matrix_set_id: str or ~geocatalog.models.Tilematrixsetid2
        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword scale: Tile size scale. 1=256x256, 2=512x512... Default value is None.
        :paramtype scale: int
        :keyword format: Output image type. Default is auto. Known values are: "png", "npy", "tif",
         "jpeg", "jpg", "jp2", "webp", and "pngraw". Default value is None.
        :paramtype format: str or ~geocatalog.models.ImageType3
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.PathsS0Ema9DataItemTilesTilematrixsetidZXYGetParameters16Schema
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm2
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.PathsT3AhfDataItemTilesTilematrixsetidZXYGetParameters20Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_tile_operations_item_tiles_tile_matrix_set_id_z_x_y_get_request(
            z=z,
            x=x,
            y=y,
            tile_matrix_set_id=tile_matrix_set_id,
            collection=collection,
            item=item,
            scale=scale,
            format=format,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def item_tiles_z_x_y_scale_x_format_get(  # pylint: disable=inconsistent-return-statements
        self,
        z: int,
        x: int,
        y: int,
        scale: int,
        format: Union[str, _models.ImageType4],
        *,
        collection: str,
        item: str,
        tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid3]] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Paths17Bc78LDataItemTilesZXYScaleXFormatGetParameters16Schema]] = None,
        algorithm: Optional[Union[str, _models.Algorithm3]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[
            Union[str, _models.Paths338ZlcDataItemTilesZXYScaleXFormatGetParameters20Schema]
        ] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Tile.

        Create map tile from a dataset.

        :param z: TMS tiles's zoom level. Required.
        :type z: int
        :param x: TMS tiles's column. Required.
        :type x: int
        :param y: TMS tiles's row. Required.
        :type y: int
        :param scale: Required.
        :type scale: int
        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~geocatalog.models.ImageType4
        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword tile_matrix_set_id: TileMatrixSet Name (default: 'WebMercatorQuad'). Known values are:
         "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad", "LINZAntarticaMapTilegrid", "NZTM2000",
         "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad", "UTM31WGS84Quad", "WGS1984Quad",
         "WebMercatorQuad", "WorldCRS84Quad", and "WorldMercatorWGS84Quad". Default value is None.
        :paramtype tile_matrix_set_id: str or ~geocatalog.models.Tilematrixsetid3
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths17Bc78LDataItemTilesZXYScaleXFormatGetParameters16Schema
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm3
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.Paths338ZlcDataItemTilesZXYScaleXFormatGetParameters20Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_tile_operations_item_tiles_z_x_y_scale_x_format_get_request(
            z=z,
            x=x,
            y=y,
            scale=scale,
            format=format,
            collection=collection,
            item=item,
            tile_matrix_set_id=tile_matrix_set_id,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def item_tiles_z_x_y_scale_x_get(  # pylint: disable=inconsistent-return-statements
        self,
        z: int,
        x: int,
        y: int,
        scale: int,
        *,
        collection: str,
        item: str,
        tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid4]] = None,
        format: Optional[Union[str, _models.ImageType5]] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Paths1Mmqnr8DataItemTilesZXYScaleXGetParameters16Schema]] = None,
        algorithm: Optional[Union[str, _models.Algorithm4]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.PathsM7PokpDataItemTilesZXYScaleXGetParameters20Schema]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Tile.

        Create map tile from a dataset.

        :param z: TMS tiles's zoom level. Required.
        :type z: int
        :param x: TMS tiles's column. Required.
        :type x: int
        :param y: TMS tiles's row. Required.
        :type y: int
        :param scale: Required.
        :type scale: int
        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword tile_matrix_set_id: TileMatrixSet Name (default: 'WebMercatorQuad'). Known values are:
         "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad", "LINZAntarticaMapTilegrid", "NZTM2000",
         "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad", "UTM31WGS84Quad", "WGS1984Quad",
         "WebMercatorQuad", "WorldCRS84Quad", and "WorldMercatorWGS84Quad". Default value is None.
        :paramtype tile_matrix_set_id: str or ~geocatalog.models.Tilematrixsetid4
        :keyword format: Output image type. Default is auto. Known values are: "png", "npy", "tif",
         "jpeg", "jpg", "jp2", "webp", and "pngraw". Default value is None.
        :paramtype format: str or ~geocatalog.models.ImageType5
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths1Mmqnr8DataItemTilesZXYScaleXGetParameters16Schema
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm4
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.PathsM7PokpDataItemTilesZXYScaleXGetParameters20Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_tile_operations_item_tiles_z_x_y_scale_x_get_request(
            z=z,
            x=x,
            y=y,
            scale=scale,
            collection=collection,
            item=item,
            tile_matrix_set_id=tile_matrix_set_id,
            format=format,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def item_tiles_z_x_y_format_get(  # pylint: disable=inconsistent-return-statements
        self,
        z: int,
        x: int,
        y: int,
        format: Union[str, _models.ImageType6],
        *,
        collection: str,
        item: str,
        tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid5]] = None,
        scale: Optional[int] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Paths1F79KueDataItemTilesZXYFormatGetParameters16Schema]] = None,
        algorithm: Optional[Union[str, _models.Algorithm5]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.Paths1Xib62VDataItemTilesZXYFormatGetParameters20Schema]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Tile.

        Create map tile from a dataset.

        :param z: TMS tiles's zoom level. Required.
        :type z: int
        :param x: TMS tiles's column. Required.
        :type x: int
        :param y: TMS tiles's row. Required.
        :type y: int
        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~geocatalog.models.ImageType6
        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword tile_matrix_set_id: TileMatrixSet Name (default: 'WebMercatorQuad'). Known values are:
         "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad", "LINZAntarticaMapTilegrid", "NZTM2000",
         "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad", "UTM31WGS84Quad", "WGS1984Quad",
         "WebMercatorQuad", "WorldCRS84Quad", and "WorldMercatorWGS84Quad". Default value is None.
        :paramtype tile_matrix_set_id: str or ~geocatalog.models.Tilematrixsetid5
        :keyword scale: Tile size scale. 1=256x256, 2=512x512... Default value is None.
        :paramtype scale: int
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths1F79KueDataItemTilesZXYFormatGetParameters16Schema
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm5
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.Paths1Xib62VDataItemTilesZXYFormatGetParameters20Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_tile_operations_item_tiles_z_x_y_format_get_request(
            z=z,
            x=x,
            y=y,
            format=format,
            collection=collection,
            item=item,
            tile_matrix_set_id=tile_matrix_set_id,
            scale=scale,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def item_tiles_z_x_y_get(  # pylint: disable=inconsistent-return-statements
        self,
        z: int,
        x: int,
        y: int,
        *,
        collection: str,
        item: str,
        tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid6]] = None,
        scale: Optional[int] = None,
        format: Optional[Union[str, _models.ImageType7]] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Paths1E8Ilq4DataItemTilesZXYGetParameters16Schema]] = None,
        algorithm: Optional[Union[str, _models.Algorithm6]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.Paths1NxuhrzDataItemTilesZXYGetParameters20Schema]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Tile.

        Create map tile from a dataset.

        :param z: TMS tiles's zoom level. Required.
        :type z: int
        :param x: TMS tiles's column. Required.
        :type x: int
        :param y: TMS tiles's row. Required.
        :type y: int
        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword tile_matrix_set_id: TileMatrixSet Name (default: 'WebMercatorQuad'). Known values are:
         "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad", "LINZAntarticaMapTilegrid", "NZTM2000",
         "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad", "UTM31WGS84Quad", "WGS1984Quad",
         "WebMercatorQuad", "WorldCRS84Quad", and "WorldMercatorWGS84Quad". Default value is None.
        :paramtype tile_matrix_set_id: str or ~geocatalog.models.Tilematrixsetid6
        :keyword scale: Tile size scale. 1=256x256, 2=512x512... Default value is None.
        :paramtype scale: int
        :keyword format: Output image type. Default is auto. Known values are: "png", "npy", "tif",
         "jpeg", "jpg", "jp2", "webp", and "pngraw". Default value is None.
        :paramtype format: str or ~geocatalog.models.ImageType7
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths1E8Ilq4DataItemTilesZXYGetParameters16Schema
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm6
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.Paths1NxuhrzDataItemTilesZXYGetParameters20Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_tile_operations_item_tiles_z_x_y_get_request(
            z=z,
            x=x,
            y=y,
            collection=collection,
            item=item,
            tile_matrix_set_id=tile_matrix_set_id,
            scale=scale,
            format=format,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def mosaic_tiles_searchid_tile_matrix_set_id_z_x_y_scale_x_format_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        z: int,
        x: int,
        y: int,
        tile_matrix_set_id: Union[str, _models.Tilematrixsetid11],
        scale: int,
        format: Union[str, _models.ImageType19],
        searchid: str,
        *,
        pixel_selection: Optional[Union[str, _models.PixelSelectionMethod0]] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        collection: Optional[str] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[
            Union[str, _models.Paths1Xj9M9TDataMosaicTilesSearchidTilematrixsetidZXYScaleXFormatGetParameters17Schema]
        ] = None,
        algorithm: Optional[Union[str, _models.Algorithm18]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[
            Union[str, _models.PathsArwi6TDataMosaicTilesSearchidTilematrixsetidZXYScaleXFormatGetParameters21Schema]
        ] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Tile.

        Create map tile.

        :param z: Tile's zoom level. Required.
        :type z: int
        :param x: Tile's column. Required.
        :type x: int
        :param y: Tile's row. Required.
        :type y: int
        :param tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000", "NZTM2000Quad", "UPSAntarcticWGS84Quad",
         "UPSArcticWGS84Quad", "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Required.
        :type tile_matrix_set_id: str or ~geocatalog.models.Tilematrixsetid11
        :param scale: Required.
        :type scale: int
        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~geocatalog.models.ImageType19
        :param searchid: Search Id. Required.
        :type searchid: str
        :keyword pixel_selection: Pixel selection method. Known values are: "first", "highest",
         "lowest", "mean", "median", and "stdev". Default value is None.
        :paramtype pixel_selection: str or ~geocatalog.models.PixelSelectionMethod0
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword collection: STAC Collection ID. Default value is None.
        :paramtype collection: str
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths1Xj9M9TDataMosaicTilesSearchidTilematrixsetidZXYScaleXFormatGetParameters17Schema
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm18
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.PathsArwi6TDataMosaicTilesSearchidTilematrixsetidZXYScaleXFormatGetParameters21Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_tile_operations_mosaic_tiles_searchid_tile_matrix_set_id_z_x_y_scale_x_format_get_request(
            z=z,
            x=x,
            y=y,
            tile_matrix_set_id=tile_matrix_set_id,
            scale=scale,
            format=format,
            searchid=searchid,
            pixel_selection=pixel_selection,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            collection=collection,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            scan_limit=scan_limit,
            items_limit=items_limit,
            time_limit=time_limit,
            exitwhenfull=exitwhenfull,
            skipcovered=skipcovered,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def mosaic_tiles_searchid_tile_matrix_set_id_z_x_y_scale_x_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        z: int,
        x: int,
        y: int,
        tile_matrix_set_id: Union[str, _models.Tilematrixsetid12],
        scale: int,
        searchid: str,
        *,
        format: Optional[Union[str, _models.ImageType20]] = None,
        pixel_selection: Optional[Union[str, _models.PixelSelectionMethod1]] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        collection: Optional[str] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[
            Union[str, _models.Paths171Khk3DataMosaicTilesSearchidTilematrixsetidZXYScaleXGetParameters17Schema]
        ] = None,
        algorithm: Optional[Union[str, _models.Algorithm19]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[
            Union[str, _models.Paths11ZouzzDataMosaicTilesSearchidTilematrixsetidZXYScaleXGetParameters21Schema]
        ] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Tile.

        Create map tile.

        :param z: Tile's zoom level. Required.
        :type z: int
        :param x: Tile's column. Required.
        :type x: int
        :param y: Tile's row. Required.
        :type y: int
        :param tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000", "NZTM2000Quad", "UPSAntarcticWGS84Quad",
         "UPSArcticWGS84Quad", "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Required.
        :type tile_matrix_set_id: str or ~geocatalog.models.Tilematrixsetid12
        :param scale: Required.
        :type scale: int
        :param searchid: Search Id. Required.
        :type searchid: str
        :keyword format: Output image type. Default is auto. Known values are: "png", "npy", "tif",
         "jpeg", "jpg", "jp2", "webp", and "pngraw". Default value is None.
        :paramtype format: str or ~geocatalog.models.ImageType20
        :keyword pixel_selection: Pixel selection method. Known values are: "first", "highest",
         "lowest", "mean", "median", and "stdev". Default value is None.
        :paramtype pixel_selection: str or ~geocatalog.models.PixelSelectionMethod1
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword collection: STAC Collection ID. Default value is None.
        :paramtype collection: str
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths171Khk3DataMosaicTilesSearchidTilematrixsetidZXYScaleXGetParameters17Schema
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm19
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.Paths11ZouzzDataMosaicTilesSearchidTilematrixsetidZXYScaleXGetParameters21Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_tile_operations_mosaic_tiles_searchid_tile_matrix_set_id_z_x_y_scale_x_get_request(
            z=z,
            x=x,
            y=y,
            tile_matrix_set_id=tile_matrix_set_id,
            scale=scale,
            searchid=searchid,
            format=format,
            pixel_selection=pixel_selection,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            collection=collection,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            scan_limit=scan_limit,
            items_limit=items_limit,
            time_limit=time_limit,
            exitwhenfull=exitwhenfull,
            skipcovered=skipcovered,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def mosaic_tiles_searchid_tile_matrix_set_id_z_x_y_format_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        z: int,
        x: int,
        y: int,
        tile_matrix_set_id: Union[str, _models.Tilematrixsetid13],
        format: Union[str, _models.ImageType21],
        searchid: str,
        *,
        scale: Optional[int] = None,
        pixel_selection: Optional[Union[str, _models.PixelSelectionMethod2]] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        collection: Optional[str] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[
            Union[str, _models.Paths1Q7509XDataMosaicTilesSearchidTilematrixsetidZXYFormatGetParameters17Schema]
        ] = None,
        algorithm: Optional[Union[str, _models.Algorithm20]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[
            Union[str, _models.Paths14Gxv0DataMosaicTilesSearchidTilematrixsetidZXYFormatGetParameters21Schema]
        ] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Tile.

        Create map tile.

        :param z: Tile's zoom level. Required.
        :type z: int
        :param x: Tile's column. Required.
        :type x: int
        :param y: Tile's row. Required.
        :type y: int
        :param tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000", "NZTM2000Quad", "UPSAntarcticWGS84Quad",
         "UPSArcticWGS84Quad", "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Required.
        :type tile_matrix_set_id: str or ~geocatalog.models.Tilematrixsetid13
        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~geocatalog.models.ImageType21
        :param searchid: Search Id. Required.
        :type searchid: str
        :keyword scale: Tile size scale. 1=256x256, 2=512x512... Default value is None.
        :paramtype scale: int
        :keyword pixel_selection: Pixel selection method. Known values are: "first", "highest",
         "lowest", "mean", "median", and "stdev". Default value is None.
        :paramtype pixel_selection: str or ~geocatalog.models.PixelSelectionMethod2
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword collection: STAC Collection ID. Default value is None.
        :paramtype collection: str
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths1Q7509XDataMosaicTilesSearchidTilematrixsetidZXYFormatGetParameters17Schema
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm20
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.Paths14Gxv0DataMosaicTilesSearchidTilematrixsetidZXYFormatGetParameters21Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_tile_operations_mosaic_tiles_searchid_tile_matrix_set_id_z_x_y_format_get_request(
            z=z,
            x=x,
            y=y,
            tile_matrix_set_id=tile_matrix_set_id,
            format=format,
            searchid=searchid,
            scale=scale,
            pixel_selection=pixel_selection,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            collection=collection,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            scan_limit=scan_limit,
            items_limit=items_limit,
            time_limit=time_limit,
            exitwhenfull=exitwhenfull,
            skipcovered=skipcovered,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def mosaic_tiles_searchid_tile_matrix_set_id_z_x_y_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        z: int,
        x: int,
        y: int,
        tile_matrix_set_id: Union[str, _models.Tilematrixsetid14],
        searchid: str,
        *,
        scale: Optional[int] = None,
        format: Optional[Union[str, _models.ImageType22]] = None,
        pixel_selection: Optional[Union[str, _models.PixelSelectionMethod3]] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        collection: Optional[str] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[
            Union[str, _models.Paths19Mg270DataMosaicTilesSearchidTilematrixsetidZXYGetParameters17Schema]
        ] = None,
        algorithm: Optional[Union[str, _models.Algorithm21]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[
            Union[str, _models.PathsIb17DtDataMosaicTilesSearchidTilematrixsetidZXYGetParameters21Schema]
        ] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Tile.

        Create map tile.

        :param z: Tile's zoom level. Required.
        :type z: int
        :param x: Tile's column. Required.
        :type x: int
        :param y: Tile's row. Required.
        :type y: int
        :param tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000", "NZTM2000Quad", "UPSAntarcticWGS84Quad",
         "UPSArcticWGS84Quad", "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Required.
        :type tile_matrix_set_id: str or ~geocatalog.models.Tilematrixsetid14
        :param searchid: Search Id. Required.
        :type searchid: str
        :keyword scale: Tile size scale. 1=256x256, 2=512x512... Default value is None.
        :paramtype scale: int
        :keyword format: Output image type. Default is auto. Known values are: "png", "npy", "tif",
         "jpeg", "jpg", "jp2", "webp", and "pngraw". Default value is None.
        :paramtype format: str or ~geocatalog.models.ImageType22
        :keyword pixel_selection: Pixel selection method. Known values are: "first", "highest",
         "lowest", "mean", "median", and "stdev". Default value is None.
        :paramtype pixel_selection: str or ~geocatalog.models.PixelSelectionMethod3
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword collection: STAC Collection ID. Default value is None.
        :paramtype collection: str
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths19Mg270DataMosaicTilesSearchidTilematrixsetidZXYGetParameters17Schema
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm21
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.PathsIb17DtDataMosaicTilesSearchidTilematrixsetidZXYGetParameters21Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_tile_operations_mosaic_tiles_searchid_tile_matrix_set_id_z_x_y_get_request(
            z=z,
            x=x,
            y=y,
            tile_matrix_set_id=tile_matrix_set_id,
            searchid=searchid,
            scale=scale,
            format=format,
            pixel_selection=pixel_selection,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            collection=collection,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            scan_limit=scan_limit,
            items_limit=items_limit,
            time_limit=time_limit,
            exitwhenfull=exitwhenfull,
            skipcovered=skipcovered,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def mosaic_tiles_searchid_z_x_y_scale_x_format_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        z: int,
        x: int,
        y: int,
        scale: int,
        format: Union[str, _models.ImageType23],
        searchid: str,
        *,
        tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid15]] = None,
        pixel_selection: Optional[Union[str, _models.PixelSelectionMethod4]] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        collection: Optional[str] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[
            Union[str, _models.Paths1Hfe401DataMosaicTilesSearchidZXYScaleXFormatGetParameters17Schema]
        ] = None,
        algorithm: Optional[Union[str, _models.Algorithm22]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[
            Union[str, _models.PathsW2Z6TwDataMosaicTilesSearchidZXYScaleXFormatGetParameters21Schema]
        ] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Tile.

        Create map tile.

        :param z: Tile's zoom level. Required.
        :type z: int
        :param x: Tile's column. Required.
        :type x: int
        :param y: Tile's row. Required.
        :type y: int
        :param scale: Required.
        :type scale: int
        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~geocatalog.models.ImageType23
        :param searchid: Search Id. Required.
        :type searchid: str
        :keyword tile_matrix_set_id: TileMatrixSet Name (default: 'WebMercatorQuad'). Known values are:
         "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad", "LINZAntarticaMapTilegrid", "NZTM2000",
         "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad", "UTM31WGS84Quad", "WGS1984Quad",
         "WebMercatorQuad", "WorldCRS84Quad", and "WorldMercatorWGS84Quad". Default value is None.
        :paramtype tile_matrix_set_id: str or ~geocatalog.models.Tilematrixsetid15
        :keyword pixel_selection: Pixel selection method. Known values are: "first", "highest",
         "lowest", "mean", "median", and "stdev". Default value is None.
        :paramtype pixel_selection: str or ~geocatalog.models.PixelSelectionMethod4
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword collection: STAC Collection ID. Default value is None.
        :paramtype collection: str
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths1Hfe401DataMosaicTilesSearchidZXYScaleXFormatGetParameters17Schema
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm22
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.PathsW2Z6TwDataMosaicTilesSearchidZXYScaleXFormatGetParameters21Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_tile_operations_mosaic_tiles_searchid_z_x_y_scale_x_format_get_request(
            z=z,
            x=x,
            y=y,
            scale=scale,
            format=format,
            searchid=searchid,
            tile_matrix_set_id=tile_matrix_set_id,
            pixel_selection=pixel_selection,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            collection=collection,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            scan_limit=scan_limit,
            items_limit=items_limit,
            time_limit=time_limit,
            exitwhenfull=exitwhenfull,
            skipcovered=skipcovered,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def mosaic_tiles_searchid_z_x_y_scale_x_get(  # pylint: disable=inconsistent-return-statements
        self,
        z: int,
        x: int,
        y: int,
        scale: int,
        searchid: str,
        *,
        tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid16]] = None,
        format: Optional[Union[str, _models.ImageType24]] = None,
        pixel_selection: Optional[Union[str, _models.PixelSelectionMethod5]] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        collection: Optional[str] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[
            Union[str, _models.Paths1JheicrDataMosaicTilesSearchidZXYScaleXGetParameters17Schema]
        ] = None,
        algorithm: Optional[Union[str, _models.Algorithm23]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[
            Union[str, _models.Paths1Yqp90WDataMosaicTilesSearchidZXYScaleXGetParameters21Schema]
        ] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Tile.

        Create map tile.

        :param z: Tile's zoom level. Required.
        :type z: int
        :param x: Tile's column. Required.
        :type x: int
        :param y: Tile's row. Required.
        :type y: int
        :param scale: Required.
        :type scale: int
        :param searchid: Search Id. Required.
        :type searchid: str
        :keyword tile_matrix_set_id: TileMatrixSet Name (default: 'WebMercatorQuad'). Known values are:
         "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad", "LINZAntarticaMapTilegrid", "NZTM2000",
         "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad", "UTM31WGS84Quad", "WGS1984Quad",
         "WebMercatorQuad", "WorldCRS84Quad", and "WorldMercatorWGS84Quad". Default value is None.
        :paramtype tile_matrix_set_id: str or ~geocatalog.models.Tilematrixsetid16
        :keyword format: Output image type. Default is auto. Known values are: "png", "npy", "tif",
         "jpeg", "jpg", "jp2", "webp", and "pngraw". Default value is None.
        :paramtype format: str or ~geocatalog.models.ImageType24
        :keyword pixel_selection: Pixel selection method. Known values are: "first", "highest",
         "lowest", "mean", "median", and "stdev". Default value is None.
        :paramtype pixel_selection: str or ~geocatalog.models.PixelSelectionMethod5
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword collection: STAC Collection ID. Default value is None.
        :paramtype collection: str
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths1JheicrDataMosaicTilesSearchidZXYScaleXGetParameters17Schema
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm23
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.Paths1Yqp90WDataMosaicTilesSearchidZXYScaleXGetParameters21Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_tile_operations_mosaic_tiles_searchid_z_x_y_scale_x_get_request(
            z=z,
            x=x,
            y=y,
            scale=scale,
            searchid=searchid,
            tile_matrix_set_id=tile_matrix_set_id,
            format=format,
            pixel_selection=pixel_selection,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            collection=collection,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            scan_limit=scan_limit,
            items_limit=items_limit,
            time_limit=time_limit,
            exitwhenfull=exitwhenfull,
            skipcovered=skipcovered,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def mosaic_tiles_searchid_z_x_y_format_get(  # pylint: disable=inconsistent-return-statements
        self,
        z: int,
        x: int,
        y: int,
        format: Union[str, _models.ImageType25],
        searchid: str,
        *,
        tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid17]] = None,
        scale: Optional[int] = None,
        pixel_selection: Optional[Union[str, _models.PixelSelectionMethod6]] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        collection: Optional[str] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[
            Union[str, _models.PathsWhganvDataMosaicTilesSearchidZXYFormatGetParameters17Schema]
        ] = None,
        algorithm: Optional[Union[str, _models.Algorithm24]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[
            Union[str, _models.Paths1Oikcy0DataMosaicTilesSearchidZXYFormatGetParameters21Schema]
        ] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Tile.

        Create map tile.

        :param z: Tile's zoom level. Required.
        :type z: int
        :param x: Tile's column. Required.
        :type x: int
        :param y: Tile's row. Required.
        :type y: int
        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~geocatalog.models.ImageType25
        :param searchid: Search Id. Required.
        :type searchid: str
        :keyword tile_matrix_set_id: TileMatrixSet Name (default: 'WebMercatorQuad'). Known values are:
         "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad", "LINZAntarticaMapTilegrid", "NZTM2000",
         "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad", "UTM31WGS84Quad", "WGS1984Quad",
         "WebMercatorQuad", "WorldCRS84Quad", and "WorldMercatorWGS84Quad". Default value is None.
        :paramtype tile_matrix_set_id: str or ~geocatalog.models.Tilematrixsetid17
        :keyword scale: Tile size scale. 1=256x256, 2=512x512... Default value is None.
        :paramtype scale: int
        :keyword pixel_selection: Pixel selection method. Known values are: "first", "highest",
         "lowest", "mean", "median", and "stdev". Default value is None.
        :paramtype pixel_selection: str or ~geocatalog.models.PixelSelectionMethod6
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword collection: STAC Collection ID. Default value is None.
        :paramtype collection: str
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.PathsWhganvDataMosaicTilesSearchidZXYFormatGetParameters17Schema
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm24
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.Paths1Oikcy0DataMosaicTilesSearchidZXYFormatGetParameters21Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_tile_operations_mosaic_tiles_searchid_z_x_y_format_get_request(
            z=z,
            x=x,
            y=y,
            format=format,
            searchid=searchid,
            tile_matrix_set_id=tile_matrix_set_id,
            scale=scale,
            pixel_selection=pixel_selection,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            collection=collection,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            scan_limit=scan_limit,
            items_limit=items_limit,
            time_limit=time_limit,
            exitwhenfull=exitwhenfull,
            skipcovered=skipcovered,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def mosaic_tiles_searchid_z_x_y_get(  # pylint: disable=inconsistent-return-statements
        self,
        z: int,
        x: int,
        y: int,
        searchid: str,
        *,
        tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid18]] = None,
        scale: Optional[int] = None,
        format: Optional[Union[str, _models.ImageType26]] = None,
        pixel_selection: Optional[Union[str, _models.PixelSelectionMethod7]] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        collection: Optional[str] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.PathsLmb8U8DataMosaicTilesSearchidZXYGetParameters17Schema]] = None,
        algorithm: Optional[Union[str, _models.Algorithm25]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.PathsFlolqDataMosaicTilesSearchidZXYGetParameters21Schema]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Tile.

        Create map tile.

        :param z: Tile's zoom level. Required.
        :type z: int
        :param x: Tile's column. Required.
        :type x: int
        :param y: Tile's row. Required.
        :type y: int
        :param searchid: Search Id. Required.
        :type searchid: str
        :keyword tile_matrix_set_id: TileMatrixSet Name (default: 'WebMercatorQuad'). Known values are:
         "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad", "LINZAntarticaMapTilegrid", "NZTM2000",
         "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad", "UTM31WGS84Quad", "WGS1984Quad",
         "WebMercatorQuad", "WorldCRS84Quad", and "WorldMercatorWGS84Quad". Default value is None.
        :paramtype tile_matrix_set_id: str or ~geocatalog.models.Tilematrixsetid18
        :keyword scale: Tile size scale. 1=256x256, 2=512x512... Default value is None.
        :paramtype scale: int
        :keyword format: Output image type. Default is auto. Known values are: "png", "npy", "tif",
         "jpeg", "jpg", "jp2", "webp", and "pngraw". Default value is None.
        :paramtype format: str or ~geocatalog.models.ImageType26
        :keyword pixel_selection: Pixel selection method. Known values are: "first", "highest",
         "lowest", "mean", "median", and "stdev". Default value is None.
        :paramtype pixel_selection: str or ~geocatalog.models.PixelSelectionMethod7
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword collection: STAC Collection ID. Default value is None.
        :paramtype collection: str
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.PathsLmb8U8DataMosaicTilesSearchidZXYGetParameters17Schema
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm25
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.PathsFlolqDataMosaicTilesSearchidZXYGetParameters21Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_tile_operations_mosaic_tiles_searchid_z_x_y_get_request(
            z=z,
            x=x,
            y=y,
            searchid=searchid,
            tile_matrix_set_id=tile_matrix_set_id,
            scale=scale,
            format=format,
            pixel_selection=pixel_selection,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            collection=collection,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            scan_limit=scan_limit,
            items_limit=items_limit,
            time_limit=time_limit,
            exitwhenfull=exitwhenfull,
            skipcovered=skipcovered,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class tilejsonOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~geocatalog.aio.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`tilejson_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def item_tile_matrix_set_id_tilejson_json_get(  # pylint: disable=name-too-long
        self,
        tile_matrix_set_id: Union[str, _models.Tilematrixsetid7],
        *,
        collection: str,
        item: str,
        tile_format: Optional[Union[str, _models.ImageType8]] = None,
        tile_scale: Optional[int] = None,
        minzoom: Optional[int] = None,
        maxzoom: Optional[int] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[
            Union[str, _models.PathsMkblsyDataItemTilematrixsetidTilejsonJsonGetParameters15Schema]
        ] = None,
        algorithm: Optional[Union[str, _models.Algorithm7]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[
            Union[str, _models.Paths1Og8YstDataItemTilematrixsetidTilejsonJsonGetParameters19Schema]
        ] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any
    ) -> _models.TileJson:
        """Tilejson.

        Return TileJSON document for a dataset.

        :param tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000", "NZTM2000Quad", "UPSAntarcticWGS84Quad",
         "UPSArcticWGS84Quad", "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Required.
        :type tile_matrix_set_id: str or ~geocatalog.models.Tilematrixsetid7
        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword tile_format: Output image type. Default is auto. Known values are: "png", "npy",
         "tif", "jpeg", "jpg", "jp2", "webp", and "pngraw". Default value is None.
        :paramtype tile_format: str or ~geocatalog.models.ImageType8
        :keyword tile_scale: Tile size scale. 1=256x256, 2=512x512... Default value is None.
        :paramtype tile_scale: int
        :keyword minzoom: Overwrite default minzoom. Default value is None.
        :paramtype minzoom: int
        :keyword maxzoom: Overwrite default maxzoom. Default value is None.
        :paramtype maxzoom: int
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.PathsMkblsyDataItemTilematrixsetidTilejsonJsonGetParameters15Schema
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm7
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.Paths1Og8YstDataItemTilematrixsetidTilejsonJsonGetParameters19Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: TileJson. The TileJson is compatible with MutableMapping
        :rtype: ~geocatalog.models.TileJson
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "tiles": [
                        "str"
                    ],
                    "attribution": "str",
                    "bounds": [
                        0.0
                    ],
                    "center": [
                        0.0
                    ],
                    "data": [
                        "str"
                    ],
                    "description": "str",
                    "grids": [
                        "str"
                    ],
                    "legend": "str",
                    "maxzoom": 0,
                    "minzoom": 0,
                    "name": "str",
                    "scheme": "str",
                    "template": "str",
                    "tilejson": "str",
                    "version": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TileJson] = kwargs.pop("cls", None)

        _request = build_tilejson_operations_item_tile_matrix_set_id_tilejson_json_get_request(
            tile_matrix_set_id=tile_matrix_set_id,
            collection=collection,
            item=item,
            tile_format=tile_format,
            tile_scale=tile_scale,
            minzoom=minzoom,
            maxzoom=maxzoom,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TileJson, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def item_tilejson_json_get(
        self,
        *,
        collection: str,
        item: str,
        tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid8]] = None,
        tile_format: Optional[Union[str, _models.ImageType9]] = None,
        tile_scale: Optional[int] = None,
        minzoom: Optional[int] = None,
        maxzoom: Optional[int] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Paths1802QymDataItemTilejsonJsonGetParameters15Schema]] = None,
        algorithm: Optional[Union[str, _models.Algorithm8]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.Paths1Wzz6Z3DataItemTilejsonJsonGetParameters19Schema]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any
    ) -> _models.TileJson:
        """Tilejson.

        Return TileJSON document for a dataset.

        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword tile_matrix_set_id: TileMatrixSet Name (default: 'WebMercatorQuad'). Known values are:
         "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad", "LINZAntarticaMapTilegrid", "NZTM2000",
         "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad", "UTM31WGS84Quad", "WGS1984Quad",
         "WebMercatorQuad", "WorldCRS84Quad", and "WorldMercatorWGS84Quad". Default value is None.
        :paramtype tile_matrix_set_id: str or ~geocatalog.models.Tilematrixsetid8
        :keyword tile_format: Output image type. Default is auto. Known values are: "png", "npy",
         "tif", "jpeg", "jpg", "jp2", "webp", and "pngraw". Default value is None.
        :paramtype tile_format: str or ~geocatalog.models.ImageType9
        :keyword tile_scale: Tile size scale. 1=256x256, 2=512x512... Default value is None.
        :paramtype tile_scale: int
        :keyword minzoom: Overwrite default minzoom. Default value is None.
        :paramtype minzoom: int
        :keyword maxzoom: Overwrite default maxzoom. Default value is None.
        :paramtype maxzoom: int
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths1802QymDataItemTilejsonJsonGetParameters15Schema
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm8
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.Paths1Wzz6Z3DataItemTilejsonJsonGetParameters19Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: TileJson. The TileJson is compatible with MutableMapping
        :rtype: ~geocatalog.models.TileJson
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "tiles": [
                        "str"
                    ],
                    "attribution": "str",
                    "bounds": [
                        0.0
                    ],
                    "center": [
                        0.0
                    ],
                    "data": [
                        "str"
                    ],
                    "description": "str",
                    "grids": [
                        "str"
                    ],
                    "legend": "str",
                    "maxzoom": 0,
                    "minzoom": 0,
                    "name": "str",
                    "scheme": "str",
                    "template": "str",
                    "tilejson": "str",
                    "version": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TileJson] = kwargs.pop("cls", None)

        _request = build_tilejson_operations_item_tilejson_json_get_request(
            collection=collection,
            item=item,
            tile_matrix_set_id=tile_matrix_set_id,
            tile_format=tile_format,
            tile_scale=tile_scale,
            minzoom=minzoom,
            maxzoom=maxzoom,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TileJson, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def mosaic_searchid_tile_matrix_set_id_tilejson_json_get(  # pylint: disable=name-too-long
        self,
        tile_matrix_set_id: Union[str, _models.Tilematrixsetid19],
        searchid: str,
        *,
        tile_format: Optional[Union[str, _models.ImageType27]] = None,
        tile_scale: Optional[int] = None,
        minzoom: Optional[int] = None,
        maxzoom: Optional[int] = None,
        pixel_selection: Optional[Union[str, _models.PixelSelectionMethod8]] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        collection: Optional[str] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[
            Union[str, _models.PathsHspvjyDataMosaicSearchidTilematrixsetidTilejsonJsonGetParameters16Schema]
        ] = None,
        algorithm: Optional[Union[str, _models.Algorithm26]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[
            Union[str, _models.PathsHevd5EDataMosaicSearchidTilematrixsetidTilejsonJsonGetParameters20Schema]
        ] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        **kwargs: Any
    ) -> _models.TileJson:
        """Tilejson.

        Return TileJSON document for a SearchId.

        :param tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000", "NZTM2000Quad", "UPSAntarcticWGS84Quad",
         "UPSArcticWGS84Quad", "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Required.
        :type tile_matrix_set_id: str or ~geocatalog.models.Tilematrixsetid19
        :param searchid: Search Id. Required.
        :type searchid: str
        :keyword tile_format: Output image type. Default is auto. Known values are: "png", "npy",
         "tif", "jpeg", "jpg", "jp2", "webp", and "pngraw". Default value is None.
        :paramtype tile_format: str or ~geocatalog.models.ImageType27
        :keyword tile_scale: Tile size scale. 1=256x256, 2=512x512... Default value is None.
        :paramtype tile_scale: int
        :keyword minzoom: Overwrite default minzoom. Default value is None.
        :paramtype minzoom: int
        :keyword maxzoom: Overwrite default maxzoom. Default value is None.
        :paramtype maxzoom: int
        :keyword pixel_selection: Pixel selection method. Known values are: "first", "highest",
         "lowest", "mean", "median", and "stdev". Default value is None.
        :paramtype pixel_selection: str or ~geocatalog.models.PixelSelectionMethod8
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword collection: STAC Collection ID. Default value is None.
        :paramtype collection: str
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.PathsHspvjyDataMosaicSearchidTilematrixsetidTilejsonJsonGetParameters16Schema
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm26
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.PathsHevd5EDataMosaicSearchidTilematrixsetidTilejsonJsonGetParameters20Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :return: TileJson. The TileJson is compatible with MutableMapping
        :rtype: ~geocatalog.models.TileJson
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "tiles": [
                        "str"
                    ],
                    "attribution": "str",
                    "bounds": [
                        0.0
                    ],
                    "center": [
                        0.0
                    ],
                    "data": [
                        "str"
                    ],
                    "description": "str",
                    "grids": [
                        "str"
                    ],
                    "legend": "str",
                    "maxzoom": 0,
                    "minzoom": 0,
                    "name": "str",
                    "scheme": "str",
                    "template": "str",
                    "tilejson": "str",
                    "version": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TileJson] = kwargs.pop("cls", None)

        _request = build_tilejson_operations_mosaic_searchid_tile_matrix_set_id_tilejson_json_get_request(
            tile_matrix_set_id=tile_matrix_set_id,
            searchid=searchid,
            tile_format=tile_format,
            tile_scale=tile_scale,
            minzoom=minzoom,
            maxzoom=maxzoom,
            pixel_selection=pixel_selection,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            collection=collection,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            scan_limit=scan_limit,
            items_limit=items_limit,
            time_limit=time_limit,
            exitwhenfull=exitwhenfull,
            skipcovered=skipcovered,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TileJson, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def mosaic_searchid_tilejson_json_get(
        self,
        searchid: str,
        *,
        tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid20]] = None,
        tile_format: Optional[Union[str, _models.ImageType28]] = None,
        tile_scale: Optional[int] = None,
        minzoom: Optional[int] = None,
        maxzoom: Optional[int] = None,
        pixel_selection: Optional[Union[str, _models.PixelSelectionMethod9]] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        collection: Optional[str] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[
            Union[str, _models.Paths1YwzaabDataMosaicSearchidTilejsonJsonGetParameters16Schema]
        ] = None,
        algorithm: Optional[Union[str, _models.Algorithm27]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[
            Union[str, _models.Paths1LskkdkDataMosaicSearchidTilejsonJsonGetParameters20Schema]
        ] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        **kwargs: Any
    ) -> _models.TileJson:
        """Tilejson.

        Return TileJSON document for a SearchId.

        :param searchid: Search Id. Required.
        :type searchid: str
        :keyword tile_matrix_set_id: TileMatrixSet Name (default: 'WebMercatorQuad'). Known values are:
         "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad", "LINZAntarticaMapTilegrid", "NZTM2000",
         "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad", "UTM31WGS84Quad", "WGS1984Quad",
         "WebMercatorQuad", "WorldCRS84Quad", and "WorldMercatorWGS84Quad". Default value is None.
        :paramtype tile_matrix_set_id: str or ~geocatalog.models.Tilematrixsetid20
        :keyword tile_format: Output image type. Default is auto. Known values are: "png", "npy",
         "tif", "jpeg", "jpg", "jp2", "webp", and "pngraw". Default value is None.
        :paramtype tile_format: str or ~geocatalog.models.ImageType28
        :keyword tile_scale: Tile size scale. 1=256x256, 2=512x512... Default value is None.
        :paramtype tile_scale: int
        :keyword minzoom: Overwrite default minzoom. Default value is None.
        :paramtype minzoom: int
        :keyword maxzoom: Overwrite default maxzoom. Default value is None.
        :paramtype maxzoom: int
        :keyword pixel_selection: Pixel selection method. Known values are: "first", "highest",
         "lowest", "mean", "median", and "stdev". Default value is None.
        :paramtype pixel_selection: str or ~geocatalog.models.PixelSelectionMethod9
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword collection: STAC Collection ID. Default value is None.
        :paramtype collection: str
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths1YwzaabDataMosaicSearchidTilejsonJsonGetParameters16Schema
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm27
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.Paths1LskkdkDataMosaicSearchidTilejsonJsonGetParameters20Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :return: TileJson. The TileJson is compatible with MutableMapping
        :rtype: ~geocatalog.models.TileJson
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "tiles": [
                        "str"
                    ],
                    "attribution": "str",
                    "bounds": [
                        0.0
                    ],
                    "center": [
                        0.0
                    ],
                    "data": [
                        "str"
                    ],
                    "description": "str",
                    "grids": [
                        "str"
                    ],
                    "legend": "str",
                    "maxzoom": 0,
                    "minzoom": 0,
                    "name": "str",
                    "scheme": "str",
                    "template": "str",
                    "tilejson": "str",
                    "version": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TileJson] = kwargs.pop("cls", None)

        _request = build_tilejson_operations_mosaic_searchid_tilejson_json_get_request(
            searchid=searchid,
            tile_matrix_set_id=tile_matrix_set_id,
            tile_format=tile_format,
            tile_scale=tile_scale,
            minzoom=minzoom,
            maxzoom=maxzoom,
            pixel_selection=pixel_selection,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            collection=collection,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            scan_limit=scan_limit,
            items_limit=items_limit,
            time_limit=time_limit,
            exitwhenfull=exitwhenfull,
            skipcovered=skipcovered,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TileJson, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class wmtsOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~geocatalog.aio.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`wmts_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def item_tile_matrix_set_id_w_m_t_s_capabilities_xml_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        tile_matrix_set_id: Union[str, _models.Tilematrixsetid9],
        *,
        collection: str,
        item: str,
        tile_format: Optional[Union[str, _models.ImageType10]] = None,
        tile_scale: Optional[int] = None,
        minzoom: Optional[int] = None,
        maxzoom: Optional[int] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[
            Union[str, _models.Paths1Vy2U93DataItemTilematrixsetidWmtscapabilitiesXmlGetParameters15Schema]
        ] = None,
        algorithm: Optional[Union[str, _models.Algorithm9]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[
            Union[str, _models.PathsAk2Tp9DataItemTilematrixsetidWmtscapabilitiesXmlGetParameters19Schema]
        ] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Wmts.

        OGC WMTS endpoint.

        :param tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000", "NZTM2000Quad", "UPSAntarcticWGS84Quad",
         "UPSArcticWGS84Quad", "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Required.
        :type tile_matrix_set_id: str or ~geocatalog.models.Tilematrixsetid9
        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword tile_format: Output image type. Default is png. Known values are: "png", "npy", "tif",
         "jpeg", "jpg", "jp2", "webp", and "pngraw". Default value is None.
        :paramtype tile_format: str or ~geocatalog.models.ImageType10
        :keyword tile_scale: Tile size scale. 1=256x256, 2=512x512... Default value is None.
        :paramtype tile_scale: int
        :keyword minzoom: Overwrite default minzoom. Default value is None.
        :paramtype minzoom: int
        :keyword maxzoom: Overwrite default maxzoom. Default value is None.
        :paramtype maxzoom: int
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths1Vy2U93DataItemTilematrixsetidWmtscapabilitiesXmlGetParameters15Schema
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm9
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.PathsAk2Tp9DataItemTilematrixsetidWmtscapabilitiesXmlGetParameters19Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        accept: Literal["application/xml"] = kwargs.pop("accept", _headers.pop("accept", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_wmts_operations_item_tile_matrix_set_id_w_m_t_s_capabilities_xml_get_request(
            tile_matrix_set_id=tile_matrix_set_id,
            collection=collection,
            item=item,
            tile_format=tile_format,
            tile_scale=tile_scale,
            minzoom=minzoom,
            maxzoom=maxzoom,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            accept=accept,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def item_w_m_t_s_capabilities_xml_get(  # pylint: disable=inconsistent-return-statements
        self,
        *,
        collection: str,
        item: str,
        tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid10]] = None,
        tile_format: Optional[Union[str, _models.ImageType11]] = None,
        tile_scale: Optional[int] = None,
        minzoom: Optional[int] = None,
        maxzoom: Optional[int] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Paths1Na4VklDataItemWmtscapabilitiesXmlGetParameters15Schema]] = None,
        algorithm: Optional[Union[str, _models.Algorithm10]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.PathsAqoqr1DataItemWmtscapabilitiesXmlGetParameters19Schema]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Wmts.

        OGC WMTS endpoint.

        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword tile_matrix_set_id: TileMatrixSet Name (default: 'WebMercatorQuad'). Known values are:
         "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad", "LINZAntarticaMapTilegrid", "NZTM2000",
         "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad", "UTM31WGS84Quad", "WGS1984Quad",
         "WebMercatorQuad", "WorldCRS84Quad", and "WorldMercatorWGS84Quad". Default value is None.
        :paramtype tile_matrix_set_id: str or ~geocatalog.models.Tilematrixsetid10
        :keyword tile_format: Output image type. Default is png. Known values are: "png", "npy", "tif",
         "jpeg", "jpg", "jp2", "webp", and "pngraw". Default value is None.
        :paramtype tile_format: str or ~geocatalog.models.ImageType11
        :keyword tile_scale: Tile size scale. 1=256x256, 2=512x512... Default value is None.
        :paramtype tile_scale: int
        :keyword minzoom: Overwrite default minzoom. Default value is None.
        :paramtype minzoom: int
        :keyword maxzoom: Overwrite default maxzoom. Default value is None.
        :paramtype maxzoom: int
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths1Na4VklDataItemWmtscapabilitiesXmlGetParameters15Schema
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm10
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.PathsAqoqr1DataItemWmtscapabilitiesXmlGetParameters19Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        accept: Literal["application/xml"] = kwargs.pop("accept", _headers.pop("accept", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_wmts_operations_item_w_m_t_s_capabilities_xml_get_request(
            collection=collection,
            item=item,
            tile_matrix_set_id=tile_matrix_set_id,
            tile_format=tile_format,
            tile_scale=tile_scale,
            minzoom=minzoom,
            maxzoom=maxzoom,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            accept=accept,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def mosaic_searchid_tile_matrix_set_id_w_m_t_s_capabilities_xml_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        tile_matrix_set_id: Union[str, _models.Tilematrixsetid21],
        searchid: str,
        *,
        tile_format: Optional[Union[str, _models.ImageType29]] = None,
        tile_scale: Optional[int] = None,
        minzoom: Optional[int] = None,
        maxzoom: Optional[int] = None,
        pixel_selection: Optional[Union[str, _models.PixelSelectionMethod10]] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        collection: Optional[str] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[
            Union[str, _models.Paths8U8V0WDataMosaicSearchidTilematrixsetidWmtscapabilitiesXmlGetParameters16Schema]
        ] = None,
        algorithm: Optional[Union[str, _models.Algorithm28]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[
            Union[str, _models.Paths1Jyeg20DataMosaicSearchidTilematrixsetidWmtscapabilitiesXmlGetParameters20Schema]
        ] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Wmts.

        OGC WMTS endpoint.

        :param tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000", "NZTM2000Quad", "UPSAntarcticWGS84Quad",
         "UPSArcticWGS84Quad", "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Required.
        :type tile_matrix_set_id: str or ~geocatalog.models.Tilematrixsetid21
        :param searchid: Search Id. Required.
        :type searchid: str
        :keyword tile_format: Output image type. Default is png. Known values are: "png", "npy", "tif",
         "jpeg", "jpg", "jp2", "webp", and "pngraw". Default value is None.
        :paramtype tile_format: str or ~geocatalog.models.ImageType29
        :keyword tile_scale: Tile size scale. 1=256x256, 2=512x512... Default value is None.
        :paramtype tile_scale: int
        :keyword minzoom: Overwrite default minzoom. Default value is None.
        :paramtype minzoom: int
        :keyword maxzoom: Overwrite default maxzoom. Default value is None.
        :paramtype maxzoom: int
        :keyword pixel_selection: Pixel selection method. Known values are: "first", "highest",
         "lowest", "mean", "median", and "stdev". Default value is None.
        :paramtype pixel_selection: str or ~geocatalog.models.PixelSelectionMethod10
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword collection: STAC Collection ID. Default value is None.
        :paramtype collection: str
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths8U8V0WDataMosaicSearchidTilematrixsetidWmtscapabilitiesXmlGetParameters16Schema
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm28
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.Paths1Jyeg20DataMosaicSearchidTilematrixsetidWmtscapabilitiesXmlGetParameters20Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        accept: Literal["application/xml"] = kwargs.pop("accept", _headers.pop("accept", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_wmts_operations_mosaic_searchid_tile_matrix_set_id_w_m_t_s_capabilities_xml_get_request(
            tile_matrix_set_id=tile_matrix_set_id,
            searchid=searchid,
            tile_format=tile_format,
            tile_scale=tile_scale,
            minzoom=minzoom,
            maxzoom=maxzoom,
            pixel_selection=pixel_selection,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            collection=collection,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            scan_limit=scan_limit,
            items_limit=items_limit,
            time_limit=time_limit,
            exitwhenfull=exitwhenfull,
            skipcovered=skipcovered,
            accept=accept,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def mosaic_searchid_w_m_t_s_capabilities_xml_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        searchid: str,
        *,
        tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid22]] = None,
        tile_format: Optional[Union[str, _models.ImageType30]] = None,
        tile_scale: Optional[int] = None,
        minzoom: Optional[int] = None,
        maxzoom: Optional[int] = None,
        pixel_selection: Optional[Union[str, _models.PixelSelectionMethod11]] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        collection: Optional[str] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[
            Union[str, _models.Paths1Is020LDataMosaicSearchidWmtscapabilitiesXmlGetParameters16Schema]
        ] = None,
        algorithm: Optional[Union[str, _models.Algorithm29]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[
            Union[str, _models.PathsNj2Os5DataMosaicSearchidWmtscapabilitiesXmlGetParameters20Schema]
        ] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Wmts.

        OGC WMTS endpoint.

        :param searchid: Search Id. Required.
        :type searchid: str
        :keyword tile_matrix_set_id: TileMatrixSet Name (default: 'WebMercatorQuad'). Known values are:
         "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad", "LINZAntarticaMapTilegrid", "NZTM2000",
         "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad", "UTM31WGS84Quad", "WGS1984Quad",
         "WebMercatorQuad", "WorldCRS84Quad", and "WorldMercatorWGS84Quad". Default value is None.
        :paramtype tile_matrix_set_id: str or ~geocatalog.models.Tilematrixsetid22
        :keyword tile_format: Output image type. Default is png. Known values are: "png", "npy", "tif",
         "jpeg", "jpg", "jp2", "webp", and "pngraw". Default value is None.
        :paramtype tile_format: str or ~geocatalog.models.ImageType30
        :keyword tile_scale: Tile size scale. 1=256x256, 2=512x512... Default value is None.
        :paramtype tile_scale: int
        :keyword minzoom: Overwrite default minzoom. Default value is None.
        :paramtype minzoom: int
        :keyword maxzoom: Overwrite default maxzoom. Default value is None.
        :paramtype maxzoom: int
        :keyword pixel_selection: Pixel selection method. Known values are: "first", "highest",
         "lowest", "mean", "median", and "stdev". Default value is None.
        :paramtype pixel_selection: str or ~geocatalog.models.PixelSelectionMethod11
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword collection: STAC Collection ID. Default value is None.
        :paramtype collection: str
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths1Is020LDataMosaicSearchidWmtscapabilitiesXmlGetParameters16Schema
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm29
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.PathsNj2Os5DataMosaicSearchidWmtscapabilitiesXmlGetParameters20Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        accept: Literal["application/xml"] = kwargs.pop("accept", _headers.pop("accept", "application/xml"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_wmts_operations_mosaic_searchid_w_m_t_s_capabilities_xml_get_request(
            searchid=searchid,
            tile_matrix_set_id=tile_matrix_set_id,
            tile_format=tile_format,
            tile_scale=tile_scale,
            minzoom=minzoom,
            maxzoom=maxzoom,
            pixel_selection=pixel_selection,
            buffer=buffer,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            collection=collection,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            scan_limit=scan_limit,
            items_limit=items_limit,
            time_limit=time_limit,
            exitwhenfull=exitwhenfull,
            skipcovered=skipcovered,
            accept=accept,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class pointOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~geocatalog.aio.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`point_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def item_point_lon_lat_get(
        self,
        lon: float,
        lat: float,
        *,
        collection: str,
        item: str,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Paths1Lyjge7DataItemPointLonLatGetParameters10Schema]] = None,
        **kwargs: Any
    ) -> _models.TitilerCoreModelsResponsesPoint:
        """Point.

        Get Point value for a dataset.

        :param lon: Longitude. Required.
        :type lon: float
        :param lat: Latitude. Required.
        :type lat: float
        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths1Lyjge7DataItemPointLonLatGetParameters10Schema
        :return: TitilerCoreModelsResponsesPoint. The TitilerCoreModelsResponsesPoint is compatible
         with MutableMapping
        :rtype: ~geocatalog.models.TitilerCoreModelsResponsesPoint
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "band_names": [
                        "str"
                    ],
                    "coordinates": [
                        0.0
                    ],
                    "values": [
                        0.0
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TitilerCoreModelsResponsesPoint] = kwargs.pop("cls", None)

        _request = build_point_operations_item_point_lon_lat_get_request(
            lon=lon,
            lat=lat,
            collection=collection,
            item=item,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TitilerCoreModelsResponsesPoint, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class previewOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~geocatalog.aio.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`preview_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def item_preview_format_get(  # pylint: disable=inconsistent-return-statements
        self,
        format: Union[str, _models.ImageType12],
        *,
        collection: str,
        item: str,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Paths1U4Cs8EDataItemPreviewFormatGetParameters10Schema]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        algorithm: Optional[Union[str, _models.Algorithm11]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.Paths1PlhplwDataItemPreviewFormatGetParameters17Schema]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Preview.

        Create preview of a dataset.

        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~geocatalog.models.ImageType12
        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths1U4Cs8EDataItemPreviewFormatGetParameters10Schema
        :keyword max_size: Maximum image size to read onto. Default value is None.
        :paramtype max_size: int
        :keyword height: Force output image height. Default value is None.
        :paramtype height: int
        :keyword width: Force output image width. Default value is None.
        :paramtype width: int
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm11
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.Paths1PlhplwDataItemPreviewFormatGetParameters17Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_preview_operations_item_preview_format_get_request(
            format=format,
            collection=collection,
            item=item,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            max_size=max_size,
            height=height,
            width=width,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def item_preview_get(  # pylint: disable=inconsistent-return-statements
        self,
        *,
        collection: str,
        item: str,
        format: Optional[Union[str, _models.ImageType13]] = None,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Paths1K322LdDataItemPreviewGetParameters10Schema]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        algorithm: Optional[Union[str, _models.Algorithm12]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.Paths9Vriu2DataItemPreviewGetParameters17Schema]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Preview.

        Create preview of a dataset.

        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword format: Output image type. Default is auto. Known values are: "png", "npy", "tif",
         "jpeg", "jpg", "jp2", "webp", and "pngraw". Default value is None.
        :paramtype format: str or ~geocatalog.models.ImageType13
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths1K322LdDataItemPreviewGetParameters10Schema
        :keyword max_size: Maximum image size to read onto. Default value is None.
        :paramtype max_size: int
        :keyword height: Force output image height. Default value is None.
        :paramtype height: int
        :keyword width: Force output image width. Default value is None.
        :paramtype width: int
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm12
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.Paths9Vriu2DataItemPreviewGetParameters17Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_preview_operations_item_preview_get_request(
            collection=collection,
            item=item,
            format=format,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            max_size=max_size,
            height=height,
            width=width,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class partOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~geocatalog.aio.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`part_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def item_crop_minx_miny_maxx_maxy_width_x_height_format_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        minx: float,
        miny: float,
        maxx: float,
        maxy: float,
        format: Union[str, _models.ImageType14],
        height: int,
        width: int,
        *,
        collection: str,
        item: str,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[
            Union[str, _models.Paths1Lo5K81DataItemCropMinxMinyMaxxMaxyWidthXHeightFormatGetParameters16Schema]
        ] = None,
        max_size: Optional[int] = None,
        algorithm: Optional[Union[str, _models.Algorithm13]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[
            Union[str, _models.Paths1111DyjDataItemCropMinxMinyMaxxMaxyWidthXHeightFormatGetParameters21Schema]
        ] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Part.

        Create image from part of a dataset.

        :param minx: Bounding box min X. Required.
        :type minx: float
        :param miny: Bounding box min Y. Required.
        :type miny: float
        :param maxx: Bounding box max X. Required.
        :type maxx: float
        :param maxy: Bounding box max Y. Required.
        :type maxy: float
        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~geocatalog.models.ImageType14
        :param height: Required.
        :type height: int
        :param width: Required.
        :type width: int
        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths1Lo5K81DataItemCropMinxMinyMaxxMaxyWidthXHeightFormatGetParameters16Schema
        :keyword max_size: Maximum image size to read onto. Default value is None.
        :paramtype max_size: int
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm13
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.Paths1111DyjDataItemCropMinxMinyMaxxMaxyWidthXHeightFormatGetParameters21Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_part_operations_item_crop_minx_miny_maxx_maxy_width_x_height_format_get_request(
            minx=minx,
            miny=miny,
            maxx=maxx,
            maxy=maxy,
            format=format,
            height=height,
            width=width,
            collection=collection,
            item=item,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            max_size=max_size,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def item_crop_minx_miny_maxx_maxy_format_get(  # pylint: disable=inconsistent-return-statements
        self,
        minx: float,
        miny: float,
        maxx: float,
        maxy: float,
        format: Union[str, _models.ImageType15],
        *,
        collection: str,
        item: str,
        color_formula: Optional[str] = None,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[Any] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[
            Union[str, _models.Paths1CpwqjyDataItemCropMinxMinyMaxxMaxyFormatGetParameters14Schema]
        ] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        algorithm: Optional[Union[str, _models.Algorithm14]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[
            Union[str, _models.PathsPd395WDataItemCropMinxMinyMaxxMaxyFormatGetParameters21Schema]
        ] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Part.

        Create image from part of a dataset.

        :param minx: Bounding box min X. Required.
        :type minx: float
        :param miny: Bounding box min Y. Required.
        :type miny: float
        :param maxx: Bounding box max X. Required.
        :type maxx: float
        :param maxy: Bounding box max Y. Required.
        :type maxy: float
        :param format: Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and
         "pngraw". Required.
        :type format: str or ~geocatalog.models.ImageType15
        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :keyword color_formula: rio-color formula (info: https://github.com/mapbox/rio-color). Default
         value is None.
        :paramtype color_formula: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes. Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: any
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", "max", "min", "med", "q1", "q3", "sum",
         and "rms". Default value is None.
        :paramtype resampling: str or
         ~geocatalog.models.Paths1CpwqjyDataItemCropMinxMinyMaxxMaxyFormatGetParameters14Schema
        :keyword max_size: Maximum image size to read onto. Default value is None.
        :paramtype max_size: int
        :keyword height: Force output image height. Default value is None.
        :paramtype height: int
        :keyword width: Force output image width. Default value is None.
        :paramtype width: int
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~geocatalog.models.Algorithm14
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or
         ~geocatalog.models.PathsPd395WDataItemCropMinxMinyMaxxMaxyFormatGetParameters21Schema
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_part_operations_item_crop_minx_miny_maxx_maxy_format_get_request(
            minx=minx,
            miny=miny,
            maxx=maxx,
            maxy=maxy,
            format=format,
            collection=collection,
            item=item,
            color_formula=color_formula,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            max_size=max_size,
            height=height,
            width=width,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class mapOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~geocatalog.aio.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`map_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def item_map_get(  # pylint: disable=inconsistent-return-statements
        self, *, collection: str, item: str, **kwargs: Any
    ) -> None:
        """Map.

        Map.

        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :keyword item: STAC Item ID. Required.
        :paramtype item: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        accept: Literal["text/html"] = kwargs.pop("accept", _headers.pop("accept", "text/html"))
        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_map_operations_item_map_get_request(
            collection=collection,
            item=item,
            accept=accept,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class registerOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~geocatalog.aio.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`register_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def search_mosaic_register_post(
        self, body: _models.RegisterMosaic, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.RegisterResponse:
        """Register Search.

        Register a Search query.

        :param body: Required.
        :type body: ~geocatalog.models.RegisterMosaic
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RegisterResponse. The RegisterResponse is compatible with MutableMapping
        :rtype: ~geocatalog.models.RegisterResponse
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "bbox": {},
                    "collections": [
                        "str"
                    ],
                    "datetime": "str",
                    "filter": {
                        "str": {}
                    },
                    "filter-lang": "str",
                    "ids": [
                        "str"
                    ],
                    "intersects": {},
                    "metadata": {
                        "assets": [
                            "str"
                        ],
                        "bounds": {},
                        "defaults": {
                            "str": {}
                        },
                        "maxzoom": 0,
                        "minzoom": 0,
                        "name": "str",
                        "type": "str"
                    },
                    "query": {
                        "str": {
                            "str": {}
                        }
                    },
                    "sortby": {}
                }

                # response body for status code(s): 200
                response == {
                    "searchid": "str",
                    "links": [
                        {
                            "href": "str",
                            "hreflang": "str",
                            "length": 0,
                            "rel": "str",
                            "title": "str",
                            "type": "str"
                        }
                    ]
                }
        """

    @overload
    async def search_mosaic_register_post(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.RegisterResponse:
        """Register Search.

        Register a Search query.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RegisterResponse. The RegisterResponse is compatible with MutableMapping
        :rtype: ~geocatalog.models.RegisterResponse
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "searchid": "str",
                    "links": [
                        {
                            "href": "str",
                            "hreflang": "str",
                            "length": 0,
                            "rel": "str",
                            "title": "str",
                            "type": "str"
                        }
                    ]
                }
        """

    @overload
    async def search_mosaic_register_post(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.RegisterResponse:
        """Register Search.

        Register a Search query.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RegisterResponse. The RegisterResponse is compatible with MutableMapping
        :rtype: ~geocatalog.models.RegisterResponse
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "searchid": "str",
                    "links": [
                        {
                            "href": "str",
                            "hreflang": "str",
                            "length": 0,
                            "rel": "str",
                            "title": "str",
                            "type": "str"
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def search_mosaic_register_post(
        self, body: Union[_models.RegisterMosaic, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.RegisterResponse:
        """Register Search.

        Register a Search query.

        :param body: Is one of the following types: RegisterMosaic, JSON, IO[bytes] Required.
        :type body: ~geocatalog.models.RegisterMosaic or JSON or IO[bytes]
        :return: RegisterResponse. The RegisterResponse is compatible with MutableMapping
        :rtype: ~geocatalog.models.RegisterResponse
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "bbox": {},
                    "collections": [
                        "str"
                    ],
                    "datetime": "str",
                    "filter": {
                        "str": {}
                    },
                    "filter-lang": "str",
                    "ids": [
                        "str"
                    ],
                    "intersects": {},
                    "metadata": {
                        "assets": [
                            "str"
                        ],
                        "bounds": {},
                        "defaults": {
                            "str": {}
                        },
                        "maxzoom": 0,
                        "minzoom": 0,
                        "name": "str",
                        "type": "str"
                    },
                    "query": {
                        "str": {
                            "str": {}
                        }
                    },
                    "sortby": {}
                }

                # response body for status code(s): 200
                response == {
                    "searchid": "str",
                    "links": [
                        {
                            "href": "str",
                            "hreflang": "str",
                            "length": 0,
                            "rel": "str",
                            "title": "str",
                            "type": "str"
                        }
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.RegisterResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_register_operations_search_mosaic_register_post_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RegisterResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class assetsOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~geocatalog.aio.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`assets_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def for_tile_mosaic_searchid_tile_matrix_set_id_z_x_y_assets_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        z: int,
        x: int,
        y: int,
        tile_matrix_set_id: Union[str, _models.Tilematrixsetid23],
        searchid: str,
        *,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Assets For Tile.

        Return a list of assets which overlap a given tile.

        :param z: Tiles's zoom level. Required.
        :type z: int
        :param x: Tiles's column. Required.
        :type x: int
        :param y: Tiles's row. Required.
        :type y: int
        :param tile_matrix_set_id: Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000", "NZTM2000Quad", "UPSAntarcticWGS84Quad",
         "UPSArcticWGS84Quad", "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Required.
        :type tile_matrix_set_id: str or ~geocatalog.models.Tilematrixsetid23
        :param searchid: Search Id. Required.
        :type searchid: str
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_assets_operations_for_tile_mosaic_searchid_tile_matrix_set_id_z_x_y_assets_get_request(
            z=z,
            x=x,
            y=y,
            tile_matrix_set_id=tile_matrix_set_id,
            searchid=searchid,
            scan_limit=scan_limit,
            items_limit=items_limit,
            time_limit=time_limit,
            exitwhenfull=exitwhenfull,
            skipcovered=skipcovered,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def for_tile_mosaic_searchid_z_x_y_assets_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        z: int,
        x: int,
        y: int,
        searchid: str,
        *,
        tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid24]] = None,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Assets For Tile.

        Return a list of assets which overlap a given tile.

        :param z: Tiles's zoom level. Required.
        :type z: int
        :param x: Tiles's column. Required.
        :type x: int
        :param y: Tiles's row. Required.
        :type y: int
        :param searchid: Search Id. Required.
        :type searchid: str
        :keyword tile_matrix_set_id: TileMatrixSet Name (default: 'WebMercatorQuad'). Known values are:
         "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad", "LINZAntarticaMapTilegrid", "NZTM2000",
         "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad", "UTM31WGS84Quad", "WGS1984Quad",
         "WebMercatorQuad", "WorldCRS84Quad", and "WorldMercatorWGS84Quad". Default value is None.
        :paramtype tile_matrix_set_id: str or ~geocatalog.models.Tilematrixsetid24
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_assets_operations_for_tile_mosaic_searchid_z_x_y_assets_get_request(
            z=z,
            x=x,
            y=y,
            searchid=searchid,
            tile_matrix_set_id=tile_matrix_set_id,
            scan_limit=scan_limit,
            items_limit=items_limit,
            time_limit=time_limit,
            exitwhenfull=exitwhenfull,
            skipcovered=skipcovered,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def for_point_mosaic_searchid_lon_lat_assets_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        lon: float,
        lat: float,
        searchid: str,
        *,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Assets For Point.

        Return a list of assets for a given point.

        :param lon: Longitude. Required.
        :type lon: float
        :param lat: Latitude. Required.
        :type lat: float
        :param searchid: Search Id. Required.
        :type searchid: str
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_assets_operations_for_point_mosaic_searchid_lon_lat_assets_get_request(
            lon=lon,
            lat=lat,
            searchid=searchid,
            scan_limit=scan_limit,
            items_limit=items_limit,
            time_limit=time_limit,
            exitwhenfull=exitwhenfull,
            skipcovered=skipcovered,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class mosaicOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~geocatalog.aio.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`mosaic_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def info_mosaic_info_get(self, *, collection: str, **kwargs: Any) -> _models.MosaicInfo:
        """Mosaic Info.

        Mosaic Info.

        :keyword collection: STAC Collection ID. Required.
        :paramtype collection: str
        :return: MosaicInfo. The MosaicInfo is compatible with MutableMapping
        :rtype: ~geocatalog.models.MosaicInfo
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "defaultLocation": {
                        "coordinates": [
                            0.0
                        ],
                        "zoom": 0
                    },
                    "mosaics": [
                        {
                            "cql": [
                                {
                                    "str": {}
                                }
                            ],
                            "name": "str",
                            "description": "str"
                        }
                    ],
                    "renderOptions": [
                        {
                            "minZoom": 0,
                            "name": "str",
                            "conditions": [
                                {
                                    "property": "str",
                                    "value": {}
                                }
                            ],
                            "description": "str",
                            "legend": {
                                "labels": [
                                    "str"
                                ],
                                "scaleFactor": 0.0,
                                "trimEnd": 0,
                                "trimStart": 0,
                                "type": "str"
                            },
                            "options": "str",
                            "type": "str",
                            "vectorOptions": {
                                "sourceLayer": "str",
                                "tilejsonKey": "str",
                                "fillColor": "str",
                                "filter": [
                                    {}
                                ],
                                "strokeColor": "str",
                                "strokeWidth": 0
                            }
                        }
                    ],
                    "animationHint": {
                        "duration": 0,
                        "frameCount": 0,
                        "step": 0,
                        "unit": "str"
                    },
                    "defaultCustomQuery": {
                        "str": {}
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MosaicInfo] = kwargs.pop("cls", None)

        _request = build_mosaic_operations_info_mosaic_info_get_request(
            collection=collection,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.MosaicInfo, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class getOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~geocatalog.aio.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`get_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def interval_legend_legend_interval_classmap_name_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, classmap_name: str, *, trim_start: Optional[int] = None, trim_end: Optional[int] = None, **kwargs: Any
    ) -> None:
        """Get Interval Legend.

        Generate values and color swatches mapping for a given interval classmap.

        Args:
        trim_start (int, optional): Number of items to trim from the start of the
        cmap
        trim_end (int, optional): Number of items to trim from the end of the cmap.

        :param classmap_name: Required.
        :type classmap_name: str
        :keyword trim_start: Default value is None.
        :paramtype trim_start: int
        :keyword trim_end: Default value is None.
        :paramtype trim_end: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_get_operations_interval_legend_legend_interval_classmap_name_get_request(
            classmap_name=classmap_name,
            trim_start=trim_start,
            trim_end=trim_end,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def classmap_legend_legend_classmap_classmap_name_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, classmap_name: str, *, trim_start: Optional[int] = None, trim_end: Optional[int] = None, **kwargs: Any
    ) -> None:
        """Get Classmap Legend.

        Generate values and color swatches mapping for a given classmap.

        Args:
        trim_start (int, optional): Number of items to trim from the start of the
        cmap
        trim_end (int, optional): Number of items to trim from the end of the cmap.

        :param classmap_name: Required.
        :type classmap_name: str
        :keyword trim_start: Default value is None.
        :paramtype trim_start: int
        :keyword trim_end: Default value is None.
        :paramtype trim_end: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_get_operations_classmap_legend_legend_classmap_classmap_name_get_request(
            classmap_name=classmap_name,
            trim_start=trim_start,
            trim_end=trim_end,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def legend_legend_colormap_cmap_name_get(  # pylint: disable=inconsistent-return-statements
        self,
        cmap_name: str,
        *,
        height: Optional[float] = None,
        width: Optional[float] = None,
        trim_start: Optional[int] = None,
        trim_end: Optional[int] = None,
        **kwargs: Any
    ) -> None:
        """Get Legend.

        Generate a legend image for a given colormap.

        If the colormap has non-contiguous values at the beginning or end,
        which aren't desired in the output image, they can be trimmed by specifying
        the number of values to trim.

        Args:
        cmap_name (string): The name of the registered colormap to generate a
        legend for
        height (float, optional): The output height of the legend image
        width (float, optional): The output width of the legend image
        trim_start (int, optional): Number of items to trim from the start of the
        cmap
        trim_end (int, optional): Number of items to trim from the end of the cmap

        Returns:
        HTTP response with jpeg encoded image data.

        :param cmap_name: Required.
        :type cmap_name: str
        :keyword height: Default value is None.
        :paramtype height: float
        :keyword width: Default value is None.
        :paramtype width: float
        :keyword trim_start: Default value is None.
        :paramtype trim_start: int
        :keyword trim_end: Default value is None.
        :paramtype trim_end: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_get_operations_legend_legend_colormap_cmap_name_get_request(
            cmap_name=cmap_name,
            height=height,
            width=width,
            trim_start=trim_start,
            trim_end=trim_end,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def tilejson_vector_collections_collection_id_tilesets_tileset_id_tilejson_json_get(  # pylint: disable=name-too-long
        self, collection_id: str, tileset_id: str, **kwargs: Any
    ) -> _models.TileJson:
        """Get Tilejson.

        Get the tilejson for a given tileset.

        :param collection_id: STAC Collection ID. Required.
        :type collection_id: str
        :param tileset_id: Registered tileset ID, see Collection metadata for valid values. Required.
        :type tileset_id: str
        :return: TileJson. The TileJson is compatible with MutableMapping
        :rtype: ~geocatalog.models.TileJson
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "tiles": [
                        "str"
                    ],
                    "attribution": "str",
                    "bounds": [
                        0.0
                    ],
                    "center": [
                        0.0
                    ],
                    "data": [
                        "str"
                    ],
                    "description": "str",
                    "grids": [
                        "str"
                    ],
                    "legend": "str",
                    "maxzoom": 0,
                    "minzoom": 0,
                    "name": "str",
                    "scheme": "str",
                    "template": "str",
                    "tilejson": "str",
                    "version": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TileJson] = kwargs.pop("cls", None)

        _request = build_get_operations_tilejson_vector_collections_collection_id_tilesets_tileset_id_tilejson_json_get_request(
            collection_id=collection_id,
            tileset_id=tileset_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TileJson, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def tile_vector_collections_collection_id_tilesets_tileset_id_tiles_z_x_y_get(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, collection_id: str, tileset_id: str, z: int, x: int, y: int, **kwargs: Any
    ) -> None:
        """Get Tile.

        Get a vector tile for a given tileset.

        :param collection_id: STAC Collection ID. Required.
        :type collection_id: str
        :param tileset_id: Registered tileset ID, see Collection metadata for valid values. Required.
        :type tileset_id: str
        :param z: Zoom. Required.
        :type z: int
        :param x: Tile column. Required.
        :type x: int
        :param y: Tile row. Required.
        :type y: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = (
            build_get_operations_tile_vector_collections_collection_id_tilesets_tileset_id_tiles_z_x_y_get_request(
                collection_id=collection_id,
                tileset_id=tileset_id,
                z=z,
                x=x,
                y=y,
                api_version=self._config.api_version,
                headers=_headers,
                params=_params,
            )
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class IngestionsRunsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~geocatalog.aio.AzureOrbitalPlanetaryComputerClient`'s
        :attr:`runs` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def list(self, ingestion_id: str, collection_id: str, **kwargs: Any) -> List[_models.IngestionRunSummary]:
        """Get the runs of an ingestion.

        :param ingestion_id: Ingestion id. Required.
        :type ingestion_id: str
        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :return: list of IngestionRunSummary
        :rtype: list[~geocatalog.models.IngestionRunSummary]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "id": "str",
                        "operation": {
                            "id": "str",
                            "status": "str"
                        }
                    }
                ]
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: cast(
                Type[HttpResponseError],
                lambda response: HttpResponseError(
                    response=response, model=_deserialize(_models.BadRequest, response.json())
                ),
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.IngestionRunSummary]] = kwargs.pop("cls", None)

        _request = build_ingestions_runs_list_request(
            ingestion_id=ingestion_id,
            collection_id=collection_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.IngestionRunSummary], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def read(self, run_id: str, ingestion_id: str, collection_id: str, **kwargs: Any) -> _models.IngestionRun:
        """Get a run of an ingestion.

        :param run_id: Run id. Required.
        :type run_id: str
        :param ingestion_id: Ingestion id. Required.
        :type ingestion_id: str
        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :return: IngestionRun. The IngestionRun is compatible with MutableMapping
        :rtype: ~geocatalog.models.IngestionRun
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 404
                response == {
                    "id": "str",
                    "operation": {
                        "creationTime": "2020-02-20 00:00:00",
                        "id": "str",
                        "status": "str",
                        "statusHistory": [
                            {
                                "status": "str",
                                "time": "2020-02-20 00:00:00",
                                "errorMessage": "str"
                            }
                        ],
                        "totalFailedItems": 0,
                        "totalItems": 0,
                        "totalPendingItems": 0,
                        "totalSuccessfullItems": 0,
                        "finishTime": "2020-02-20 00:00:00",
                        "startTime": "2020-02-20 00:00:00"
                    },
                    "parentRunId": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.IngestionRun] = kwargs.pop("cls", None)

        _request = build_ingestions_runs_read_request(
            run_id=run_id,
            ingestion_id=ingestion_id,
            collection_id=collection_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.IngestionRun, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.IngestionRun, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def create(
        self, ingestion_id: str, collection_id: str, import_file: Optional[bytes] = None, **kwargs: Any
    ) -> _models.IngestionRun:
        """Create a new run of an ingestion.

        :param ingestion_id: Ingestion id. Required.
        :type ingestion_id: str
        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param import_file: Ingestion import file. *Required for ImportFile ingestion type. Default
         value is None.
        :type import_file: bytes
        :return: IngestionRun. The IngestionRun is compatible with MutableMapping
        :rtype: ~geocatalog.models.IngestionRun
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201, 404
                response == {
                    "id": "str",
                    "operation": {
                        "creationTime": "2020-02-20 00:00:00",
                        "id": "str",
                        "status": "str",
                        "statusHistory": [
                            {
                                "status": "str",
                                "time": "2020-02-20 00:00:00",
                                "errorMessage": "str"
                            }
                        ],
                        "totalFailedItems": 0,
                        "totalItems": 0,
                        "totalPendingItems": 0,
                        "totalSuccessfullItems": 0,
                        "finishTime": "2020-02-20 00:00:00",
                        "startTime": "2020-02-20 00:00:00"
                    },
                    "parentRunId": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: cast(
                Type[HttpResponseError],
                lambda response: HttpResponseError(
                    response=response, model=_deserialize(_models.BadRequest, response.json())
                ),
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))
        cls: ClsType[_models.IngestionRun] = kwargs.pop("cls", None)

        if import_file is not None:
            _content = json.dumps(import_file, cls=SdkJSONEncoder, exclude_readonly=True, format="base64")  # type: ignore
        else:
            _content = None

        _request = build_ingestions_runs_create_request(
            ingestion_id=ingestion_id,
            collection_id=collection_id,
            api_version=self._config.api_version,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 404]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 201:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.IngestionRun, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.IngestionRun, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def retry(self, run_id: str, ingestion_id: str, collection_id: str, **kwargs: Any) -> _models.IngestionRun:
        """Retries a run of an ingestion processing failed items.

        :param run_id: Run id. Required.
        :type run_id: str
        :param ingestion_id: Ingestion id. Required.
        :type ingestion_id: str
        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :return: IngestionRun. The IngestionRun is compatible with MutableMapping
        :rtype: ~geocatalog.models.IngestionRun
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201, 404
                response == {
                    "id": "str",
                    "operation": {
                        "creationTime": "2020-02-20 00:00:00",
                        "id": "str",
                        "status": "str",
                        "statusHistory": [
                            {
                                "status": "str",
                                "time": "2020-02-20 00:00:00",
                                "errorMessage": "str"
                            }
                        ],
                        "totalFailedItems": 0,
                        "totalItems": 0,
                        "totalPendingItems": 0,
                        "totalSuccessfullItems": 0,
                        "finishTime": "2020-02-20 00:00:00",
                        "startTime": "2020-02-20 00:00:00"
                    },
                    "parentRunId": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            400: cast(
                Type[HttpResponseError],
                lambda response: HttpResponseError(
                    response=response, model=_deserialize(_models.BadRequest, response.json())
                ),
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.IngestionRun] = kwargs.pop("cls", None)

        _request = build_ingestions_runs_retry_request(
            run_id=run_id,
            ingestion_id=ingestion_id,
            collection_id=collection_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 404]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 201:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.IngestionRun, response.json())

        if response.status_code == 404:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.IngestionRun, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore
